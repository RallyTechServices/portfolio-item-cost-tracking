<!DOCTYPE html>
<html>
<head>
    <title>portfolio-item-cost-tracking</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('PortfolioItemCostTracking', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    defaults: {
        startDate: new Date('2015-06-01'),
        endDate: new Date('2016-05-31'),
        groupByRelease: false
    },

    config: {
        defaultSettings: {
            selectedCalculationType: 'points',
            normalizedCostPerUnit: 1000,
            projectCostPerUnit: {},
            currencySign: '$'
        }
    },

    items: [],

    portfolioItemRollupData: {},

    launch: function() {

        //ToDO: check for RPM?

        //Initialize the filter values...
        var state = Ext.state.Manager.get(this.getContext().getScopedStateId('cb-type')),
            state_val = state ? state.value : null;


       Deft.Promise.all([
            PortfolioItemCostTracking.WsapiToolbox.fetchPortfolioItemTypes(),
            PortfolioItemCostTracking.WsapiToolbox.fetchDoneStates(),
            PortfolioItemCostTracking.WsapiToolbox.fetchModelTypePathByTypeDefinition(state_val)
        ]).then({
            scope: this,
            success: function(results){
                this._initializeSettings(this.getSettings(), results[1], results[0]);
                this._createPickers();
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: msg});
            }
        });
    },
    _createPickers: function(){

        this.fixedHeader = Ext.create('Ext.container.Container',{
            itemId: 'header-controls',
            width: 460,
            height: 50,
            layout: 'hbox',
            padding: '0 0 20 20',
            margin: 10,
            items: [{
                xtype: 'rallydatefield',
                itemId: 'dt-start',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('dt-start'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                value: this.defaults.startDate,
                padding: 5,
                fieldLabel: 'Start Date',
                labelSeparator: '',
                labelCls: 'lbl',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: this.updateStoreFilters
                }
            },{
                xtype: 'rallydatefield',
                itemId: 'dt-end',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('dt-end'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                labelSeparator: '',
                labelCls: 'lbl',
                value: this.defaults.endDate,
                fieldLabel: 'End Date',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: this.updateStoreFilters
                }
            },{
                xtype: 'rallyportfolioitemtypecombobox',
                itemId: 'cb-type',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('cb-type'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                fieldLabel: 'Portfolio Item Type',
                labelAlign: 'top',
                labelCls: 'lbl',
                listeners: {
                    scope: this,
                    ready: function (picker) {
                        console.log('ready');
                    }
                }
            }]
        });
        this.fixedHeader.down('#cb-type').on('change', this._onTypeChange, this);
    },
    _onTypeChange: function(piPicker){
        var piType = piPicker.getRecord().get('TypePath');
        this.modelNames = [piType];
        this._initializeGrid(this.modelNames);
    },
    _initializeSettings: function(settings, doneScheduleStates, portfolioItemTypes){

        PortfolioItemCostTracking.Settings.notAvailableText = "--";
        PortfolioItemCostTracking.Settings.currencySign = settings.currencySign;
        PortfolioItemCostTracking.Settings.currencyPrecision = 0;
        PortfolioItemCostTracking.Settings.currencyEnd = false;
        if (doneScheduleStates){
            PortfolioItemCostTracking.Settings.completedScheduleStates = doneScheduleStates;
        }
        if (portfolioItemTypes){
            PortfolioItemCostTracking.Settings.portfolioItemTypes = portfolioItemTypes;
        }

        PortfolioItemCostTracking.Settings.normalizedCostPerUnit = settings.normalizedCostPerUnit;

        var project_cpu = settings.projectCostPerUnit || {};
        if (!Ext.isObject(project_cpu)){
            project_cpu = Ext.JSON.decode(project_cpu);
        }
        PortfolioItemCostTracking.Settings.projectCostPerUnit = project_cpu;

        PortfolioItemCostTracking.Settings.setCalculationType(settings.selectedCalculationType);
    },
     _initializeGrid: function(modelNames){

         if (this.rollupData){
             this.rollupData.clearRollupData();
         }

         if (this.down('treegridcontainer')){
             if (this.fixedHeader && this.fixedHeader.rendered) {
                 var parent = this.fixedHeader.up();
                 if(parent && parent.remove){
                     parent.remove(this.fixedHeader, false);
                 }
             }
             this.down('treegridcontainer').destroy();
        }

        var filters = this._getDateFilters();
        console.log('filters', filters.toString());
        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            filters: filters,
            fetch: PortfolioItemCostTracking.Settings.getTreeFetch(),
            enableHierarchy: true,
            listeners: {
                scope: this,
                load: this._setRollupData
            }
        }).then({
            scope: this,
            success: function(store) {
                console.log('store',store.listeners);
                store.model.addField({name: '_rollupDataPreliminaryBudget', type: 'auto', defaultValue: null, displayName: 'Preliminary Budget'});
                store.model.addField({name: '_rollupDataTotalCost', type: 'auto', defaultValue: null, displayName: 'Total Cost'});
                store.model.addField({name: '_rollupDataRemainingCost', type: 'auto', defaultValue: null, displayName: 'Remaining Cost'});
                store.model.addField({name: '_rollupDataActualCost', type: 'auto', defaultValue: null, displayName: 'Actual Cost'});
                store.model.addField({name: '_rollupDataToolTip', type: 'string', defaultValue: null});

                this._updateDisplay(store, modelNames);
            }
        });
    },
    getStartDate: function(){
        return this.getDate('dt-start',this.defaults.startDate);
    },
    getEndDate: function(){
        return this.getDate('dt-end',this.defaults.endDate);
    },
    getDate: function(itemId, defaultDate){
        var dt = defaultDate,
            cmpId = '#' + itemId;

        if (this.down(cmpId)){
            dt = this.down(cmpId).getValue();
        } else {
            var state = Ext.state.Manager.get(this.getContext().getScopedStateId(itemId));
            if (state && state.value){
                dt = new Date(state.value);
            }
        }
        return dt;
    },
    addHeader: function (gb) {
        var header = gb.getHeader();

        if (header) {
            header.getLeft().add(this.fixedHeader);
        }
    },
    _showExportMenu: function () {
        var filters = this._getDateFilters(),//Todo: Add custom filter settings
            fetch = PortfolioItemCostTracking.Settings.getTreeFetch(),
            root_model = this.modelNames[0],
            export_columns = this._getExportColumns(); //Todo: add fetch settings

         PortfolioItemCostTracking.Utilities.fetchExportData(root_model,filters,fetch,export_columns).then({
            scope: this,
            success: function(results){
                console.log('success',results);
                var cols = this._getFormattedIDExportColumns(root_model).concat(export_columns);
                var rows = [];
                _.each(results, function(row_hash){
                    var row = [];
                    _.each(cols, function(c){
                        var col_idx = c;
                        if (Ext.isObject(c)){
                            col_idx = c.dataIndex || c.costField;
                        }
                        console.log(c,row_hash);
                        row.push(row_hash[col_idx] || null);
                    });
                    rows.push(row.join(','));
                });
                var csv = rows.join("\r\n");
               console.log('csv',csv);

            },
            failure: function(msg){
                console.log('failure',msg);
            }
        });
    },
    _getFormattedIDExportColumns: function(rootModel){
        var cols = [];
        var pi_types = PortfolioItemCostTracking.Settings.getPortfolioItemTypes();
        var idx = _.indexOf(pi_types,rootModel.toLowerCase());
        if (idx >= 0){
            cols = pi_types.slice(idx);
        }
        cols.push('hierarchicalrequirement');
        return cols;
    },
    _getExportColumns: function(){
        var cols = this._getColumnCfgs().concat(this._getCustomColumns());
        return cols;
        //Todo - order columns in same order as grid...
    },
    _getDateFilters: function(){

        var start_date = this.getStartDate(),
            end_date = this.getEndDate();

        var filter_actual = [{
            property: 'ActualEndDate',
            operator: '>=',
            value: Rally.util.DateTime.toIsoString(start_date)
        },{
            property: 'ActualEndDate',
            operator: '<',
            value: Rally.util.DateTime.toIsoString(end_date)
        }];
        filter_actual = Rally.data.wsapi.Filter.and(filter_actual);

        var filter_planned = [{
            property: 'ActualEndDate',
            value: null
        },{
            property: 'PlannedEndDate',
            operator: '<',
            value: Rally.util.DateTime.toIsoString(end_date)
        },{
            property: 'PlannedEndDate',
            operator: '>=',
            value: Rally.util.DateTime.toIsoString(start_date)
        }];
        filter_planned = Rally.data.wsapi.Filter.and(filter_planned);

        return filter_actual.or(filter_planned);
    },
    updateStoreFilters: function(){
        if (this.down('treegridcontainer')){
            this.down('treegridcontainer').storeConfig.filters = this._getDateFilters();
            this.down('treegridcontainer').applyCustomFilter(this.down('treegridcontainer').currentCustomFilter);
        }
    },
    _setRollupData: function(store, node, records, success){
         var rollup_data = this.rollupData;
        console.log('_setrollupData', store, node, records.length, success);
        if (!rollup_data) {
            this.rollupData = new PortfolioItemCostTracking.RollupData();
            rollup_data = this.rollupData;
        }

        _.each(records, function(r) {
            rollup_data.setRollupData(r);
        }, this);

    },
    _updateStore: function(fields){
        var filters = this._getDateFilters();

        var field_names = Ext.Array.map(fields, function(f){ return f.get('name'); });

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: this.modelNames,
            filters: filters,
            fetch: PortfolioItemCostTracking.Settings.getTreeFetch(field_names),
            enableHierarchy: true,
            listeners: {
                scope: this,
                load: this._setRollupData
            }
        }).then({
            scope: this,
            success: function(store) {

                store.model.addField({name: '_rollupDataPreliminaryBudget', type: 'auto', defaultValue: null, displayName: 'Preliminary Budget'});
                store.model.addField({name: '_rollupDataTotalCost', type: 'auto', defaultValue: null, displayName: 'Total Cost'});
                store.model.addField({name: '_rollupDataRemainingCost', type: 'auto', defaultValue: null, displayName: 'Remaining Cost'});
                store.model.addField({name: '_rollupDataActualCost', type: 'auto', defaultValue: null, displayName: 'Actual Cost'});
                store.model.addField({name: '_rollupDataToolTip', type: 'string', defaultValue: null});

                this.down('treegridcontainer').gridConfig.columnCfgs = this._getColumnCfgs(fields);
                this.down('treegridcontainer').updateStore(store);
                //this._updateDisplay(store, modelNames);
            }
        });
    },
    _updateDisplay: function(store, modelNames){
        var me = this;

        this.add({
            xtype: 'treegridcontainer',
            context: this.getContext(),

            gridConfig: {
                columnCfgs: this._getColumnCfgs(),
                customColumns: this._getCustomColumns(),
                store: store
            //    stateId: this.getContext().getScopedStateId('cost-grid-test11'),
            //    stateful: true
            },
            plugins:[{
                ptype: 'treegridcontainercustomfiltercontrol',
                filterControlConfig: {
                    modelNames: modelNames,
                    //stateful: true,
                    //stateId: this.getContext().getScopedStateId('cost-grid-filter'),
                    margin: '15px 10px 0px 0px'
                },
                showOwnerFilter: true,
                ownerFilterControlConfig: {
                    //stateful: true,
                    //stateId: this.getContext().getScopedStateId('cost-grid-owner-filter'),
                    margin: '15px 10px 0px 0px'
                }
            },{
                ptype: 'treegridcontainerfieldpicker',
                headerPosition: 'left',
                modelNames: modelNames,
                alwaysSelectedFields: ['_rollupDataPreliminaryBudget','_rollupDataTotalCost','_rollupDataRemainingCost','_rollupDataActualCost'],
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('cost-grid-field-picker'),
                margin: '15px 0px 10px 10px'
            },{
                ptype: 'rallygridboardactionsmenu',
                menuItems: [
                    {
                        text: 'Export...',
                        handler: me._showExportMenu,
                        scope: me
                    }
                ],
                buttonConfig: {
                    iconCls: 'icon-export',
                    margin: '15px 10px 0px 0px'
                }
            }],
            listeners: {
                beforerender: function(gb){
                    this.addHeader(gb);
                },
                updatefields: function(fields){
                    this._updateStore(fields);
                },
                scope: this
            },
            height: this.getHeight()
        });
    },
    _getCustomColumns: function(){
        return [{
            text: "Actual Cost To Date",
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataActualCost'
        },{
            text: "Remaining Cost",
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataRemainingCost'
            //dataIndex: '_rollupDataPreliminaryBudget',
        }, {
            text: 'Total Projected',
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataTotalCost'
        },{
            text: 'Preliminary Budget',
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataPreliminaryBudget'
        }];
    },
    _getColumnCfgs: function(fields){
        if (fields){
            return Ext.Array.map(fields, function(f){ return { dataIndex: f.get('name'), text: f.get('displayName') }; });
        }

        return  [{
            dataIndex: 'Name',
            text: 'Name',
            flex: 5
        },{
            dataIndex: 'Project',
            text: 'Project',
            editor: false
        },{
            dataIndex: 'PlanEstimate',
            text: 'Plan Estimate'
        }, {
            dataIndex: 'PercentDoneByStoryPlanEstimate',
            text: '% Done by Story Points'
        }];

    },
    getSettingsFields: function() {
        return PortfolioItemCostTracking.Settings.getFields(this.getSettings());
    },
    onSettingsUpdate: function(settings){
        this._initializeSettings(settings);
        this._initializeGrid(this.modelNames);
    }
});

                Ext.define('PortfolioItemCostTracking.Settings', {
    singleton: true,

    /**
     * App Settings
     */
    selectedCalculationType: undefined,
    /**
     * Currency display settings to pass into the Ext.util.Format currency function
     */
    currencySign: '$',
    currencyPrecision: 0,
    currencyEnd: false,

    normalizedCostPerUnit: 1,
    projectCostPerUnit: {},

    /**
     * App configurations
     */

    calculationTypes: {
        points: {
            key: 'points',
            label: 'Based on Story Points',
            displayName: 'Story Points',
            defaultColumns: ['Name', 'Project', 'PlanEstimate', 'LeafStoryPlanEstimateTotal'],
            additionalStoryFetch: ['PlanEstimate'],
            actualUnitsForStoryFn: function(data){
                if (data.PlanEstimate && Ext.Array.contains(PortfolioItemCostTracking.Settings.completedScheduleStates, data.ScheduleState)) {
                    return data.PlanEstimate || 0;
                }
                return 0;
            },
            totalUnitsForStoryFn: function(data){
                return data.PlanEstimate || 0;
            }
        },
        taskHours: {
            key: 'taskHours',
            displayName: 'Task Actuals',
            label: 'Based on Task Actuals',
            defaultColumns: ['Name','Project'],
            additionalStoryFetch: ['TaskEstimateTotal','TaskActualTotal','TaskRemainingTotal'],
            actualUnitsForStoryFn: function(data){ return data.TaskActualTotal || 0; },
            totalUnitsForStoryFn: function(data){
                return (data.TaskActualTotal || 0) + (data.TaskRemainingTotal || 0);
            },
            actualUnitsForTaskFn: function(data){
                return data.Actuals || 0;
            },
            totalUnitsForTaskFn: function(data){
                return (data.ToDo || 0) + (data.Actuals || 0);
            }
        },
        timesheets: {
            key: 'timesheets',
            displayName: 'Time Spent',
            label: 'Based on Timesheets',
            defaultColumns: ['Name','Project'],
            additionalStoryFetch: [],
            disabled: true,
            actualUnitsForStoryFn: function(data){ return 0; },
            actualUnitsForTaskFn: function(data){ return 0; },
            totalUnitsForStoryFn: function(data){  return 0; },
            totalUnitsForTaskFn: function(data){  return 0; }
        }
    },

    portfolioItemFetch: ['ObjectID','FormattedID','Parent','Children','UserStories','PreliminaryEstimate','Value'],
    storyFetch: ['ObjectID','FormattedID','Project','ScheduleState','PortfolioItem'],
    treeFetch: ['ObjectID','FormattedID','Name','Project','PreliminaryEstimate','PlanEstimate','PercentDoneByStoryPlanEstimate','AcceptedLeafStoryPlanEstimateTotal','LeafStoryPlanEstimateTotal','Children','ToDo','Actuals'],

    notAvailableText: '--',

    completedScheduleStates: [],

    currencyData: [
        {name: "US Dollars", value: "$"},
        {name: "Euro", value: "&#128;"},
        {name: "Japanese Yen", value: "&#165;"},
        {name: "Brazilian Real", value: "R$"}
    ],
    setCalculationType: function(type){
        console.log('setCalculationType', type);
        //Check that actuals is on, and warn user if it is not.
        if (type === 'taskHours'){
            Rally.data.ModelFactory.getModel({
                type: 'task',
                success: function(model){
                    var field = model.getField('Actuals');
                    console.log('validate', field);
                    if (field && field.hidden){
                        Rally.ui.notify.Notifier.showWarning({message: 'The Task Actuals field is not visible in the current project.  As a result, Task Actuals values may be 0.'});
                    }
                }
            });
        }


        if (PortfolioItemCostTracking.Settings.calculationTypes[type]){
            PortfolioItemCostTracking.Settings.selectedCalculationType = type;
        } else {
            PortfolioItemCostTracking.Settings.selectedCalculationType = 'points';
        }
    },
    getPortfolioItemTypes: function(){
        return _.map(this.portfolioItemTypes, function(p){ return p.toLowerCase(); });
    },
    getCalculationTypeSettings: function(){
        return PortfolioItemCostTracking.Settings.calculationTypes[PortfolioItemCostTracking.Settings.selectedCalculationType] || PortfolioItemCostTracking.Settings.calculationTypes.points;
    },
    getCalculationTypeDisplayName: function(){
        return PortfolioItemCostTracking.Settings.getCalculationTypeSettings().displayName || 'Unknown';
    },
    formatCost: function(cost){
        return Ext.util.Format.currency(cost,
            PortfolioItemCostTracking.Settings.currencySign,
            PortfolioItemCostTracking.Settings.currencyPrecision,
            PortfolioItemCostTracking.Settings.currencyEnd);
    },
    getCostPerUnit: function(project_ref){
        return PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref] || PortfolioItemCostTracking.Settings.normalizedCostPerUnit;
    },

    isProjectUsingNormalizedCost: function(project_ref){
        if (PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref]){
            return false;
        }
        return true;
    },
    getTreeFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }
        return Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.treeFetch);
    },
    getStoryFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }
        console.log('Settings.getStoryFetch', fetch);
        fetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.storyFetch);
        console.log('Settings.getStoryFetch 1', fetch);

        fetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.getCalculationTypeSettings().additionalStoryFetch);
        console.log('Settings.getStoryFetch 2', fetch);

        return fetch;
    },
    getPortfolioItemFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }
        return Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.portfolioItemFetch);
    },

    getFields: function(config) {

        var current_calculation_type = (config && config.selectedCalculationType) || 'points',
            current_project_costs = (config && config.projectCostPerUnit) || {};

        var currency_store = Ext.create('Rally.data.custom.Store', {
            data: PortfolioItemCostTracking.Settings.currencyData
        });
        var labelWidth = 100;

        var cost_items = [];
        _.each(PortfolioItemCostTracking.Settings.calculationTypes, function(obj, key){
            cost_items.push({
                boxLabel: obj.label || key,
                name: 'selectedCalculationType',
                inputValue: key,
                disabled: obj.disabled || false,
                checked: key === current_calculation_type
            });
        });

        return [{
            xtype: 'rallycombobox',
            name: 'currencySign',
            store: currency_store,
            displayField: 'name',
            valueField: 'value',
            fieldLabel:  'Currency',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Calculate Cost',
            columns: 1,
            vertical: true,
            labelWidth: labelWidth,
            margin: '10 0 10 0',
            items: cost_items
        },{
            xtype: 'rallytextfield',
            name: 'normalizedCostPerUnit',
            fieldLabel: 'Normalized Cost Per Unit',
            labelWidth: labelWidth,
            width: 200,
            margin: '25 0 0 0'
        },{
            xtype: 'costperprojectsettings',
            name: 'projectCostPerUnit',
            fieldLabel: 'Optionally define costs per unit for individual teams (exceptions to the normalized cost)',
            labelAlign: 'top',
            margin: '25 0 0 0',
           // value: current_project_costs,
            readyEvent: 'ready'
        }];
    }
});
                Ext.define('PortfolioItemCostTracking.WsapiToolbox', {
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchModelTypePathByTypeDefinition: function(typeDef){
        var deferred = Ext.create('Deft.Deferred');
        var typeDefId = 0;
        if (typeDef){
            typeDefId = typeDef.replace('/typedefinition/','');
        }

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            fetch: ['TypePath','Name'],
            filters: [{
                property: 'ObjectID',
                value: typeDefId
            }]
        }).load({
            callback: function(records, operation, success){
                if (success && records && records.length > 0){
                    deferred.resolve(records[0].get('TypePath'));
                } else {
                    deferred.resolve(null); //(Ext.String.format("Error getting TypeDefinition for {1}: {0}", operation.error.errors.join(','), typeDef));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec === null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        return deferred;
    },
    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'TypeDefinition',
            fetch: ['TypePath', 'Ordinal'],
            filters: [{
                property: 'TypePath',
                operator: 'contains',
                value: 'PortfolioItem/'
            }],
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }]
        });
        store.load({
            callback: function(records, operation, success){
                if (success){
                    var portfolioItemTypes = new Array(records.length);
                    _.each(records, function(d){
                        //Use ordinal to make sure the lowest level portfolio item type is the first in the array.
                        var idx = Number(d.get('Ordinal'));
                        portfolioItemTypes[idx] = d.get('TypePath');
                        //portfolioItemTypes.reverse();
                    });
                    deferred.resolve(portfolioItemTypes);
                } else {
                    var error_msg = '';
                    if (operation && operation.error && operation.error.errors){
                        error_msg = operation.error.errors.join(',');
                    }
                    deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                }
            }
        });
        return deferred.promise;
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') == "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});

                Ext.define('PortfolioItemCostTracking.CostPerProjectSettings',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.costperprojectsettings',
    config: {
        value: undefined,
        decodedValue: {}
    },
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){

        this.callParent();
        this.addEvents('ready');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name'],
            context: {
                project: null
            },
            limit: 'Infinity'
        });
        store.load({
            scope: this,
            callback: this._buildProjectGrid
        });

    },

    _buildProjectGrid: function(records, operation, success){

        var decodedValue = {};

        if (this.value && !_.isEmpty(this.value)){
            if (!Ext.isObject(this.value)){
                decodedValue = Ext.JSON.decode(this.value);
            } else {
                decodedValue = this.value;
            }
            console.log('decodedValue',decodedValue);
        }

        var data = [],
            empty_text = "No exceptions";

        if (success) {
            _.each(records, function(project){
                var cost = decodedValue[project.get('_ref')] || null;
                if (cost){
                    data.push({projectRef: project.get('_ref'), projectName: project.get('Name'), cost: cost});
                }
            });
        } else {
            empty_text = "Error(s) fetching Project data: <br/>" + operation.error.errors.join('<br/>');
        }

        var custom_store = Ext.create('Ext.data.Store', {
            fields: ['projectRef', 'projectName', 'cost'],
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
           // showRowActionsColumn: false,
            showPagingToolbar: false,
            store: custom_store,
            maxHeight: 300,
            margin: '20 0 0 0',
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        var width = Math.max(this.inputEl.getWidth(true),300);

        Ext.create('Rally.ui.Button',{
            text: 'Select Projects',
            renderTo: this.inputEl,
            margin: '10 0 0 0',
            listeners: {
                scope: this,
                click: function(){

                    Ext.create('ProjectPickerDialog',{
                        autoShow: true,
                        maxHeight: 400,
                        maxWidth: 400,
                        width: Math.min(width, 400),
                        title: 'Choose Project',
                        selectedRefs: _.pluck(data, 'projectRef'),
                        listeners: {
                            scope: this,
                            itemschosen: function(items){
                                var new_data = [],
                                    store = this._grid.getStore();

                                _.each(items, function(item){
                                    if (!store.findRecord('projectRef',item.get('_ref'))){
                                        new_data.push({
                                            projectRef: item.get('_ref'),
                                            projectName: item.get('Name'),
                                            cost: null
                                        });
                                    }
                                });
                                this._grid.getStore().add(new_data);
                            }
                        }
                    });
                }
            }
        });

       this.fireEvent('ready', true);
    },
    _removeProject: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            scope: this,
            rowActionsFn: function(record){
                return  [
                    {text: 'Remove', record: record, handler: me._removeProject, grid: me._grid }
                ];
            },
            //Need to override this since we are using a custom store
            _renderGearIcon: function(value, metaData, record) {
                return '<div class="row-action-icon icon-gear"/>';
            }
        },{
                text: 'Project',
                dataIndex: 'projectRef',
                flex: 1,
                editor: false,
                renderer: function(v, m, r){
                    return r.get('projectName');
                },
                getSortParam: function(v,m,r){
                    return 'projectName';
                }
        },{
            text: 'Cost Per Unit',
            dataIndex: 'cost',
            editor: {
                xtype: 'rallynumberfield'
            },
            renderer: function(v){
                if (v && v > 0){
                    return v;
                }
                return "Use Default";
            }
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {};
        var store = this._grid.getStore();

        store.each(function(record) {
            if (record.get('cost') && record.get('projectRef')) {
                mappings[record.get('projectRef')] = record.get('cost');
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('PortfolioItemCostTracking.RollupData', {
        extend: 'Ext.Base',

        mixins: {
            observable: 'Ext.util.Observable'
        },
        data: undefined,

        additionalFetch: undefined,

        constructor: function (config) {
           this.mixins.observable.constructor.call(this, config);
           this.additionalFetch = (config && config.fetch) || [];
        },
        /**
         * Clears out the data in the tree (called if settings are updated/changed, etc
         */
        clearRollupData: function (key) {
            if (key && this.data) {
                //Just clear this item
                this.data[key] = null;
            } else {
                //Clear everything
                this.data = {};
            }
        },
        getRollupItem: function (key) {

            if (!this.data) {
                this.data = {};
            }
            return this.data[key] || null;
        },
        addRollupItem: function (record) {
            if (!this.data) {
                this.data = {};
            }
            var key = record.get('ObjectID');
            this.data[key] = new PortfolioItemCostTracking.RollupDataItem({
                record: record
            });
            return this.data[key];
        },
        setRollupData: function (record) {
            var rollup_data = this.getRollupItem(record.get('ObjectID'));
            console.log('setRollupData', record.get('FormattedID'), rollup_data);

            if (rollup_data) {
                //If we already loaded the data, then use that, we don't want to take the time to reload.
                this._setDataOnModel(record, rollup_data);
                this.fireEvent('dataUpdated', rollup_data);
                return;
            }

            this._buildRollupData(record).then({
                scope: this,
                success: function (data) {
                    this.fireEvent('dataUpdated', data);
                },
                failure: function (msg) {
                    this.fireEvent('error', msg);
                }
            });
        },
        getExportableRollupData: function(rootObjectIDs, columns){

            var exportData = [];

            _.each(rootObjectIDs, function(oid){
                var obj = this.getRollupItem(oid);
                if (obj){
                    var rec = this._getExportDataRow(obj, columns);
                    exportData.push(rec);
                    this._addExportChildren(obj,exportData, columns);
                }
            },this);
            return exportData;
        },
        _addExportChildren: function(obj, exportData, columns){
            var children = obj.children;
            if (children && children.length > 0){
                _.each(children, function(c){
                    var row = this._getExportDataRow(this.getRollupItem(c),columns);
                    exportData.push(row);
                    this._addExportChildren(this.getRollupItem(c), exportData, columns);
                }, this);
            }
            return;
        },
        _getExportDataRow: function(obj, columns){
            var rec = {},
                type = obj.getData('type');

            rec[type] = obj.getData('FormattedID');
            _.each(columns, function(c){
                var field = c.dataIndex || c.costField || null;
                if (field){
                    rec[field] = obj.getData(field);
                }
             });
            return rec;
        },
        _buildRollupData: function (record) {
            console.log('_buildRollupData');
            var deferred = Ext.create('Deft.Deferred');
            var key = record.get('ObjectID');
            var item = this.addRollupItem(record);
            console.log('item', item, record.get('_type'), record.get('UserStories'));
            if (PortfolioItemCostTracking.Utilities.isPortfolioItem(record.get('_type'))) {
                if (record.get('UserStories')) {  //If this is the lowest level PI, then get the first level User Stories
                    console.log('_fetchTopLevelUserStories');
                    this._fetchTopLevelUserStories([key]).then({
                        scope: this,
                        success: function () {
                            this._setDataOnModel(record, item);
                            deferred.resolve(item);
                        },
                        failure: function (operation) {
                            deferred.reject(operation);
                        }
                    });
                } else { //else this does not have a UserStories field and is not the lowest level PI
                    if (record.get('Children') && record.get('Children').Count > 0) {
                        var child_model_type = this._getChildPortfolioModelType(record.get('_type'));
                        console.log('_fetchChildPortfolioItems');
                        this._fetchChildPortfolioItems(child_model_type, [key]).then({
                            scope: this,
                            success: function () {
                                this._calculatePortfolioItemRollupData(key);
                                this._setDataOnModel(record, item);
                                deferred.resolve(item);
                            },
                            failure: function (operation) {
                                //console.log('_buildRollupData._fetchChildPortfolioItems failure', operation);
                                deferred.reject(operation);
                            }
                        });
                    }
                } // end if is the lowest level PI
            } else { // else this is not a PI
                this._setDataOnModel(record, item);
                deferred.resolve(this.getRollupItem(key));
            } //end if is a PI
            return deferred;
        },
        _getDataObj: function (record) {
            return new PortfolioItemCostTracking.RollupDataItem({
                record: record
            });
        },
        _calculatePortfolioItemRollupData: function (key) {
            var data = this.getRollupItem(key);
            if (data && PortfolioItemCostTracking.Utilities.isPortfolioItem(data.type) &&
                (data.type.toLowerCase() !== PortfolioItemCostTracking.Settings.portfolioItemTypes[0].toLowerCase())) {
                _.each(data.children, function (childKey) {
                    this._calculatePortfolioItemRollupData(childKey);
                    data.addChildRollupData(this.getRollupItem(childKey));
                }, this);
            }
        },

        _setDataOnModel: function (record, data) {
            record.set('_rollupDataPreliminaryBudget', data._rollupDataPreliminaryBudget);
            record.set('_rollupDataTotalCost', data._rollupDataTotalCost);
            record.set('_rollupDataActualCost', data._rollupDataActualCost);
            record.set('_rollupDataRemainingCost', data._rollupDataRemainingCost);
            record.set('_rollupDataToolTip', data.getTooltip() || null);
        },

        _getChildPortfolioModelType: function (portfolioItemType) {
            var found = Ext.Array.filter(PortfolioItemCostTracking.Settings.portfolioItemTypes, function (item) {
                return item.toLowerCase() === portfolioItemType.toLowerCase();
            });

            if (found && found.length > 0) {
                var idx = _.indexOf(PortfolioItemCostTracking.Settings.portfolioItemTypes, found[0]);
                if (idx > 0) {
                    return PortfolioItemCostTracking.Settings.portfolioItemTypes[idx - 1].toLowerCase();
                }
            }
            return null;
        },
        _fetchChildPortfolioItems: function (portfolioItemType, portfolioItemObjectIDs) {

            var portfolioItemFetch = PortfolioItemCostTracking.Settings.getPortfolioItemFetch(this.additionalFetch);
            console.log('portfolioItemFetch', portfolioItemFetch, this.additionalFetch);
            var filters = _.map(portfolioItemObjectIDs, function (poid) {
                return {
                    property: 'Parent.ObjectID',
                    value: poid
                };
            });
            filters = Rally.data.wsapi.Filter.or(filters);

            return PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords(portfolioItemType, filters, portfolioItemFetch, {project: null}).then({
                scope: this,
                success: function (records) {

                    var child_model_type = this._getChildPortfolioModelType(portfolioItemType);
                    _.each(records, function (r) {
                        if (r.get('Parent') && r.get('Parent').ObjectID) {
                            var parent = r.get('Parent').ObjectID;
                            this.getRollupItem(parent).addChild(r);
                        }
                        this.addRollupItem(r);
                    }, this);

                    var obj_ids = _.map(records, function (r) {
                        return r.get('ObjectID');
                    });
                    if (records.length > 0 && child_model_type) {
                        return this._fetchChildPortfolioItems(child_model_type, obj_ids);
                    } else {
                        return this._fetchTopLevelUserStories(obj_ids);
                    }
                }
            });
        },
        _fetchTopLevelUserStories: function (portfolioItemObjectIDs) {
            var deferred = Ext.create('Deft.Deferred');

            if (portfolioItemObjectIDs.length === 0) {
                deferred.resolve();
            }

            var filters = _.map(portfolioItemObjectIDs, function (pi_oid) {
                return {
                    property: 'PortfolioItem.ObjectID',
                    value: pi_oid
                };
            });
            filters = Rally.data.wsapi.Filter.or(filters);
            var storyFetch = PortfolioItemCostTracking.Settings.getStoryFetch(this.additionalFetch);
            console.log('storyFetch', storyFetch, this.additionalFetch);
            PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords('HierarchicalRequirement', filters, storyFetch, {project: null}).then({
                scope: this,
                success: function (records) {
                    _.each(records, function (r) {
                        if (r.get('PortfolioItem') && r.get('PortfolioItem').ObjectID) {
                            var obj_id = r.get('PortfolioItem').ObjectID;
                            this.getRollupItem(obj_id).addChild(r);
                            this.addRollupItem(r);
                        }
                    }, this);
                    deferred.resolve();
                },
                failure: function (operation) {
                    deferred.reject(operation);
                }
            });
            return deferred;
        }
    });
})();
                Ext.define('PortfolioItemCostTracking.RollupDataItem',{

    children: undefined,
    type: undefined,

    totalUnits: null,
    actualUnits: null,
    _rollupDataPreliminaryBudget: null,
    _rollupDataTotalCost: 0,
    _rollupDataActualCost: 0,
    _rollupDataRemainingCost: 0,
    tooltip: undefined,
    projectCosts: undefined,
    /**
     * data is from the record associated with the rollup data
     */
    data: undefined,

    constructor: function(config){
        this.data = config.record.getData();
        this.type = config.record.get('_type');

        this._updateProjectNameAndCostHash(this.data.Project);

        this._rollupDataPreliminaryBudget = this.calculatePreliminaryBudget(this.data);

        if ((this.type.toLowerCase() === 'hierarchicalrequirement' )||(this.type.toLowerCase() === 'task')){
            this.actualUnits = this.getActualUnits(this.data,this.type.toLowerCase());
            this.totalUnits = this.getTotalUnits(this.data,this.type.toLowerCase());
            this._rollupDataActualCost = this.calculateCost(this.data, this.actualUnits);
            this._rollupDataTotalCost = this.calculateCost(this.data, this.totalUnits);
            console.log('story',this._rollupDataActualCost,this._rollupDataTotalCost);
            if (this._rollupDataActualCost === null || this._rollupDataTotalCost === null) {
                this._rollupDataRemainingCost = null;
            } else {
                this._rollupDataRemainingCost = this._rollupDataTotalCost - this._rollupDataActualCost ;
            }
        }

        //Init the rollup data
        if (PortfolioItemCostTracking.Utilities.isPortfolioItem(this.type)){
            this.totalUnits = 0;
            this._rollupDataTotalCost = 0;
            this.actualUnits = 0;
            this._rollupDataActualCost = 0;
            this._rollupDataRemainingCost = 0;
        }
    },
    getData: function(field){
         if (this[field] || this[field] === 0 ) {
            return this[field];
        }
        if (this.data[field] || this.data[field] === 0){
            return this.data[field];
        }
        return null;
    },
    addChild: function(record){
        var childType = record.get('_type'),
            childData = record.getData();

        if (record.get('_type').toLowerCase() === 'hierarchicalrequirement'){
            this._updateProjectNameAndCostHash(childData.Project);
            var total_units = this.getTotalUnits(childData, childType) || 0,
                actual_units = this.getActualUnits(childData, childType) || 0;

            this.totalUnits = (this.totalUnits || 0) + total_units;
            this.actualUnits = (this.actualUnits || 0) + actual_units;

            this._rollupDataTotalCost = (this._rollupDataTotalCost || 0) + (this.calculateCost(childData, total_units) || 0);
            this._rollupDataActualCost = (this._rollupDataActualCost || 0) + (this.calculateCost(childData, actual_units) || 0);
            this._rollupDataRemainingCost = this._rollupDataTotalCost  - this._rollupDataActualCost;
            console.log('addchild', this._rollupDataRemainingCost);

        }

        if (!this.children){
            this.children = [];
        }
        this.children.push(childData.ObjectID);
    },

    /**
     * addChildRollupData
     * @param childData
     */
    addChildRollupData: function(childData){
        console.log('addChildRollupData',childData);
        this.totalUnits = (this.totalUnits || 0) + childData.totalUnits;
        this._rollupDataTotalCost = (this._rollupDataTotalCost || 0) + childData._rollupDataTotalCost ;

        this.actualUnits = (this.actualUnits || 0) + childData.actualUnits;
        this._rollupDataActualCost = (this._rollupDataActualCost || 0) + childData._rollupDataActualCost;

        this._rollupDataRemainingCost = (this._rollupDataRemainingCost || 0) + childData._rollupDataRemainingCost;

        this.projectCosts = Ext.merge(this.projectCosts || {}, childData.projectCosts || {});
    },
    getTooltip: function(){
        var completed  = PortfolioItemCostTracking.Settings.notAvailableText;
        if ((this.actualUnits !== null) && (this.totalUnits !== null)){
            completed = Ext.String.format("{0}/{1}", this.actualUnits, this.totalUnits);
        }

        var calc_type_name = PortfolioItemCostTracking.Settings.getCalculationTypeDisplayName();

        var html = Ext.String.format('{0} completed {1}<br/><br/>Cost per unit:<br/>', calc_type_name, completed);
        _.each(this.projectCosts, function(project_cost, project_name){
            html += Ext.String.format('{0} {1}<br/>', PortfolioItemCostTracking.Settings.formatCost(project_cost), project_name);
        });

        return html;

    },
    _updateProjectNameAndCostHash: function(project){

        this.projectCosts = this.projectCosts || {};

        var name = project._refObjectName,
            cost = PortfolioItemCostTracking.Settings.getCostPerUnit(project._ref);

        if (PortfolioItemCostTracking.Settings.isProjectUsingNormalizedCost(project._ref)){
            name =  "normalized (default)";
        }
        this.projectCosts[name] = cost;
    },
    calculateCost: function(data, units){
        if (units === null){
            return null;
        }
        return units * PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
    },
    getActualUnits: function(data, modelType){
        var calcType = PortfolioItemCostTracking.Settings.getCalculationTypeSettings(),
            fn = 'actualUnitsForStoryFn';

        if (modelType.toLowerCase() === 'task'){
            fn = 'actualUnitsForTaskFn';
        }

        if (calcType[fn]) {
            return calcType[fn](data);
        }
        return null;
    },
    getTotalUnits: function(data, modelType){
        var calcType = PortfolioItemCostTracking.Settings.getCalculationTypeSettings(),
            fn = 'totalUnitsForStoryFn';

        if (modelType.toLowerCase() === 'task'){
            fn = 'totalUnitsForTaskFn';
        }
        if (calcType[fn]) {
            return calcType[fn](data);
        }
        return null;
    },
    calculatePreliminaryBudget: function(data){

        if (data && data.PreliminaryEstimate && data.PreliminaryEstimate.Value){
            var cpu = PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
            return cpu * data.PreliminaryEstimate.Value;
        }
        return null;
    }
});

                

Ext.define('ProjectPickerDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.projectpickerdialog',


    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemschosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemschosen', this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },
    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }
        Ext.create('Rally.data.wsapi.ProjectTreeStoreBuilder').build({
            models: ['project'],
            autoLoad: true,
            enableHierarchy: true,
            filters: [{
                property: 'Parent',
                value: ""
            }]
        }).then({
            scope: this,
            success: function(store) {

                var mode = this.multiple ? 'MULTI' : 'SINGLE';

                var checkbox_model = Ext.create('Rally.ui.selection.CheckboxModel', {
                    mode: mode,
                    enableKeyNav: false,
                    allowDeselect: true
                });

                this.grid = this.add({
                    xtype: 'rallytreegrid',
                    treeColumnDataIndex: 'Name',
                    treeColumnHeader: 'Name',
                    viewConfig: {
                        cls: 'grid-view-bulk-edit'
                    },
                    enableRanking: false,
                    enableEditing: false,
                    enableBulkEdit: false,
                    shouldShowRowActionsColumn: false,

                    selModel: checkbox_model,
                    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                        store = store.treeStore || store;
                        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('Name')).apply(record.data);
                    },
                    columnCfgs: [],
                    store: store
                });

                this.mon(this.grid, {
                    beforeselect: this._onGridSelect,
                    beforedeselect: this._onGridDeselect,
                    load: this._onGridLoad,
                    scope: this
                });
                this.add(this.grid);
                this._onGridReady();
            }
        });
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);

        console.log('selectionModel',selectionModel, record);

        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }
        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },
    _onGridLoad: function() {
        //console.log('_onGridLoad');
        var store = this.grid.store;
        var records = [];
        _.each(this.selectionCache, function(record) {
            var foundNode = store.getRootNode().findChild('_ref', record.get('_ref'),true);

            if (foundNode) {
                records.push(foundNode);
            }
        });
        if (records.length) {
            this.grid.getSelectionModel().select(records);
        }
    },
    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        //Filter functions call store load so we don't need to refresh the selections becuaes the
        //onGridLoad function will
        if (terms) {
            store.filter([
                Ext.create('Rally.data.wsapi.Filter',{
                    property: 'Name',
                    operator: 'contains',
                    value: terms
                })
            ]);
        } else {
            store.clearFilter();
        }

    },
    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

Ext.override(Rally.data.wsapi.ParentChildMapper, {
    constructor: function() {
        this.parentChildTypeMap = {
            project: [{
                typePath: 'project', collectionName: 'Children', parentField: 'Parent'
            }],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    }
});


Ext.define('Rally.data.wsapi.ProjectTreeStore', {

    // Client Metrics Note: WsapiTreeStore is too low level to record its load begins/ends. The problem is
    // client metrics can only reliably keep track of one load per component at a time. WsapiTreeStore makes
    // no guarantee that only one load will happen at a time. It's better to measure the component that is using
    // the store. All is not lost, the actual data requests that WsapiTreeStore makes *are* measured by client metrics.

    requires: [
        'Deft.promise.Deferred',
        'Rally.data.ModelFactory',
        'Rally.ui.grid.data.NodeInterface',
        'Rally.data.ModelTypes',
        'Rally.data.wsapi.ParentChildMapper'
    ],
    extend: 'Rally.data.wsapi.TreeStore',
    alias: 'store.rallyprojectwsapitreestore',

    /**
     * The type definition typePaths to render as root items (required)
     * @cfg {String[]} parentTypes
     */
    parentTypes: ['project'],

    /**
     * @property
     * @private
     */
    childLevelSorters: [{
        property: 'Name',
        direction: 'ASC'
    }],

    getParentFieldNamesByChildType: function(childType, parentType) {
        var model = this.model; //.getArtifactComponentModel(childType);
        return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
            var typePath = field.typePath,
                fieldName = field.fieldName,
            // hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);
                hasFieldModel = model.hasField(fieldName);

            if (hasFieldModel) {
                acc.push(fieldName.replace(/\s+/g, ''));
            }
        }, [], this);
    },

    filter: function(filters) {
        this.fireEvent('beforefilter', this);
        //We need to clear the filters to remove the Parent filter
        this.filters.clear();
        this.filters.addAll(filters);
        this._resetCurrentPage();
        this.load();
    },

    clearFilter: function(suppressEvent) {
        this._resetCurrentPage();
        this.filters.clear();
        //We need to add the parent filter back in
        this.filters.addAll(Ext.create('Rally.data.wsapi.Filter',{
            property: 'Parent',
            value: ''
        }));

        if (!suppressEvent) {
            this.load();
        }
    }
});

Ext.define('Rally.data.wsapi.ProjectTreeStoreBuilder', {
    extend: 'Rally.data.wsapi.TreeStoreBuilder',

    build: function(config) {
        //A context needs to be passed in here, and it NEEDS to be a DataContext (context.getDataContext())
        //otherwise you will get a bunch of garbage on your WSAPI request

        config = _.clone(config || {});
        config.storeType = 'Rally.data.wsapi.ProjectTreeStore';

        return this.loadModels(config).then({
            success: function(models) {
                models = _.values(models);
                return this._buildStoreWithModels(models, config);
            },
            scope: this
        });
    }
});
                Ext.define('Ext.CostTemplate', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.costtemplatecolumn'],

    tpl: '',
    costField: '',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}" style="cursor:pointer;">{[this.getCost(values)]}</div></tpl>',{
            costField: me.costField,
            getCost: function(values){
                if (values[this.costField] === null){
                    return PortfolioItemCostTracking.Settings.notAvailableText;
                } else {
                    return PortfolioItemCostTracking.Settings.formatCost(values[this.costField] || 0);
                }
            },
            getTooltip: function(values){
                if (values._rollupDataToolTip){
                    return values._rollupDataToolTip;
                }
                return '';
            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    getValue: function(){

        return this.values[this.costField] || 0;
    },
    defaultRenderer: function(value, meta, record) {

        var data = Ext.apply({}, record.data, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});

Ext.override(Rally.ui.grid.TreeGrid,{
    _isStatefulColumn: function(columnName) {
        if (!this.allColumnsStateful) {
            columnName = columnName.toLowerCase();

            var found = _.filter(this.nonStatefulColumns, function(c){
                return c.toLowerCase() === columnName;
            });
            if (found){
                return false;
            }

            if (this.store.enableHierarchy && columnName === this.treeColumnDataIndex.toLowerCase()) {
                return false;
            }

            if (this.enableRanking && columnName === this.rankColumnDataIndex.toLowerCase()) {
                return false;
            }
        }

        return true;
    }
});

                
Ext.define('TreeGridContainerCustomFilterControl', {
    alias: 'plugin.treegridcontainercustomfiltercontrol',
    extend:'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',

    showControl: function() {
        if (!this.controlCmp) {
            this._createControlCmp();
        }

        if (this.controlCmp) {
            this.controlCmp.show();
        }

        return this.controlCmp;
    }
});

                    Ext.define('TreeGridContainerFieldPicker', {
        alias: 'plugin.treegridcontainerfieldpicker',
        extend:'Ext.AbstractPlugin',
        mixins: ['Rally.ui.gridboard.plugin.GridBoardControlShowable'],
        requires: [
            'Rally.ui.popover.Popover',
            'Rally.ui.Button',
            'Rally.ui.picker.FieldPicker'
        ],

        /**
         * @cfg {String[]} alwaysSelectedFields
         * The fields that will be always selected in the field picker for the grid view
         */
        gridAlwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

        /**
         * @cfg {String[]} gridFieldBlackList
         * The fields that will be blacklisted in grid mode
         */
        gridFieldBlackList: [
            'Actuals',
            'Changesets',
            'Children',
            'Description',
            'Notes',
            'ObjectID',
            'Predecessors',
            'RevisionHistory',
            'Subscription',
            'Successors',
            'TaskIndex',
            'Workspace',
            'VersionId'
        ],

        /**
         * @cfg {String[]}
         * the names of the models displayed on the board.
         */
        modelNames: [],

        stateful: true,

        margin: '3 9 10 10',

        constructor: function (config) {
            config.gridFieldBlackList = _.union(this.gridFieldBlackList, config.gridFieldBlackList);
            config.gridAlwaysSelectedValues = _.union(this.gridAlwaysSelectedValues, config.gridAlwaysSelectedValues);
            this.callParent(arguments);
        },

        init: function(cmp) {
            this.callParent(arguments);
            this.cmp = cmp;

            var rankingEnabled = this.cmp.getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled && cmp.gridConfig.enableRanking !== false;

            this.gridAlwaysSelectedValues = this._modifyFieldCollection(this.gridAlwaysSelectedValues, ['DragAndDropRank'], rankingEnabled);
            this.gridFieldBlackList = this._modifyFieldCollection(this.gridFieldBlackList, ['DragAndDropRank'], !rankingEnabled);
            this.stateId = this.stateId || this.cmp.getContext().getScopedStateId('shownfields');

            var state = Ext.state.Manager.get(this.stateId);
            this._fields = state && state.fields;

            this.showControl();
        },
        showControl: function() {
            if (!this.controlCmp) {
                this._createControlCmp();
            }

            if (this.controlCmp) {
                this.controlCmp.show();
            }

            return this.controlCmp;
        },
        _modifyFieldCollection: function (collection, fields, include) {
            if (include) {
                return _.union(collection, fields);
            }
            return _.reject(collection, function (field) { return _.contains(fields, field); });
        },

        getControlCmpConfig: function() {
            return {
                xtype: "rallybutton",
                itemId: 'fieldpickerbtn',
                cls: 'field-picker-btn secondary rly-small',
                margin: this.margin,
                iconCls: 'icon-add-column',
                toolTipConfig: {
                    html: this.getTitle(),
                    anchor: 'top'
                },
                listeners: {
                    click: this._onClick,
                    scope: this
                }
            };
        },

        _onClick: function(btn) {
            this._createPopover(btn.getEl());
        },

        _getPickerConfig: function() {
            var pickerConfig;

            pickerConfig = _.extend({
                value: _.pluck(this.cmp.getGrid().columns, 'dataIndex').join(','),
                fieldBlackList: this.gridFieldBlackList,
                alwaysSelectedValues: this.gridAlwaysSelectedValues
            }, this.fieldPickerConfig);

            return pickerConfig;
        },

        _createPopover: function(popoverTarget) {
            this.popover = Ext.create('Rally.ui.popover.Popover', {
                target: popoverTarget,
                placement: ['bottom', 'left', 'top', 'right'],
                cls: 'field-picker-popover',
                toFront: Ext.emptyFn,
                buttonAlign: 'center',
                title: this.getTitle(),
                listeners: {
                    destroy: function () {
                        this.popover = null;
                    },
                    scope: this
                },
                buttons: [
                    {
                        xtype: "rallybutton",
                        text: 'Apply',
                        cls: 'field-picker-apply-btn primary rly-small',
                        listeners: {
                            click: function() {
                                this._onApply(this.popover);
                            },
                            scope: this
                        }
                    },
                    {
                        xtype: "rallybutton",
                        text: 'Cancel',
                        cls: 'field-picker-cancel-btn secondary dark rly-small',
                        listeners: {
                            click: function() {
                                this.popover.close();
                            },
                            scope: this
                        }
                    }
                ],
                items: [
                    _.extend({
                        xtype: 'rallyfieldpicker',
                        cls: 'field-picker',
                        itemId: 'fieldpicker',
                        modelTypes: this._getModelTypes(),
                        alwaysExpanded: true,
                        width: 200,
                        placeholderText: 'Search',
                        selectedTextLabel: 'Selected',
                        availableTextLabel: 'Available',
                        listeners: {
                            specialkey: function(field, e) {
                                if (e.getKey() === e.ESC) {
                                    this.popover.close();
                                }
                            },
                            scope: this
                        }
                    }, this._getPickerConfig())
                ]
            });
        },

        _getModelTypes: function() {
            return _.pluck(this._getModels(), 'typePath');
        },

        _getModels: function() {
            return _.reduce(this.cmp.getModels(), function(accum, model) {
                if (model.typePath === 'artifact') {
                    accum = accum.concat(model.getArtifactComponentModels());
                } else {
                    accum.push(model);
                }
                return accum;
            }, []);
        },


        getTitle: function () {
            return 'Show Columns';
        },

        /**
         * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
         * the fields on the cards
         *
         * @param {String[]|Object[]} fields A list of field names to display
         * @param {Boolean} true to suspend store load if it will be triggered elsewhere
         */
        updateFields: function (fields, suspendLoad) {
            this._fields = _.map(fields, function (field) {
                return field.get('name');
            });

            this.cmp.updateFields(fields,false,suspendLoad);
            this._updatePickerValue(this._fields);

            this.cmp.fireEvent('viewstatesave', this);
        },

        _updatePickerValue: function(fields) {
            if (this.popover && this.popover.down('rallyfieldpicker')) {
                this.popover.down('rallyfieldpicker').setValue(this._fields.join(','));
            }
        },

        _onApply: function(popover) {
            var fieldPicker = popover.down('rallyfieldpicker'),
                fields = _.map(fieldPicker.getValue(), function (field) {
                    return field.get('name');
                });

            this.updateFields(fieldPicker.getValue());

            popover.close();
        }
    });

                Ext.define('TreeGridContainer', {
    extend: 'Ext.Container',
    mixins: ['Rally.app.Scopeable'],
    requires: [
        'Rally.ui.LeftRight',
        'Rally.ui.grid.TreeGrid'
    ],

    alias: 'widget.treegridcontainer',
    cls: 'rui-gridboard',
    /**
     * @cfg {Object}
     * Common store configuration properties
     * to be applied to both the board and grid views
     */
    storeConfig: {},
    gridConfig: {},
    /**
     * @cfg {Array}
     * An array of model names of types to view on the grid board.
     */
    modelNames: [],
    /**
     * @inheritdoc
     */
    layout: {
        type: 'auto'
    },

    currentCustomFilter: [],

    items: [
        {
            itemId: 'header',
            xtype: 'rallyleftright',
            padding: '4 10 10 10',
            overflowX: 'hidden'
        }
    ],
    initComponent: function () {
        this.plugins = this.plugins || [];
        this.stateId = this.getAppContextOrEnvironmentContext().getScopedStateId(this.stateId);

        this.callParent(arguments);

        this.addEvents([
        /**
         * @event load
         * Fires when the data store for the grid or board has loaded.
         * @param {Rally.ui.gridboard.GridBoard} this
         */
            'load',
        /**
         * @event recordcreate
         * Fires when a new record is created.
         * @param {Ext.data.Record} record The record that was created.
         */
            'recordcreate',
        /**
         * @event recordupdate
         * Fires when a record is updated.
         */
            'recordupdate',
        /**
         * @event preferencesaved
         * Fires after the preference has been saved
         * @param {Rally.data.wsapi.Model} record for preference
         */
            'preferencesaved',
        /**
         * @event modeltypeschange
         * Fires when the model types of the gridboard are changed.
         */
            'modeltypeschange',
        /**
         * @event updatefields
         * Fires when the fields are updated via the field picker.
         */
            'updatefields'
        ]);

        this.on('modeltypeschange', function (gridboard, types) {
            this.modelNames = types;
        }, this);
    },
    /**
     * Delay the addition of the grid or board until plugins had a chance to modify some state
     * and the header has rendered in order to set the height of the tree grid.
     * Plugins can modify things like what fields are displayed
     * @private
     */
    afterRender: function () {
        this.callParent(arguments);
        this._addGrid();
    },
    destroy: function () {
        var grid = this.getGrid();

        if (grid && grid.store && _.isFunction(grid.store.clearData)) {
            //clean up records in the store to free up memory
            grid.store.clearData();
        }

        this.callParent(arguments);
    },
    getGrid: function () {
        return this.down('rallytreegrid');
    },
    /**
     * Get the header
     * @return {Rally.ui.LeftRight}
     */
    getHeader: function () {
        return this.down('#header');
    },
    /**
     * Get the names of the artifacts currently shown
     * @returns {String[]}
     */
    getModelNames: function () {
        return this.modelNames;
    },
    /**
     * Get the models of the artifacts currently shown
     * @returns {Rally.data.Model[]}
     */
    getModels: function () {
        return this.getGrid().getModels();
    },
    applyCustomFilter: function (filterObj) {
        var grid = this.getGrid();

        this.currentCustomFilter = filterObj;

        if (grid) {
            this._applyGridFilters(grid, filterObj);
        }
    },
    /**
     * Returns the currently applied filter.
     *
     * @returns {Ext.util.Filter|Ext.util.Filter[]|Object|Object[]}
     */
    getFilter: function () {
        return this.currentFilter;
    },

    setHeight: function () {
        this.callParent(arguments);
        var grid = this.getGrid();
        if (grid && grid.rendered && grid.getHeight() !== this.getAvailableGridBoardHeight()) {
            this.grid().setHeight(this.getAvailableGridBoardHeight());
        }
    },
    /**
     * @private
     */
    getAvailableGridBoardHeight: function () {
        return this.getHeight() - this.down('#header').getHeight() - 10;
    },
    _mergeColumnConfigs: function(newColumns, oldColumns) {
        var columns  = _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, {dataIndex: this._getDataIndex(newColumn)});
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);

        _.each(oldColumns, function(c){
            if (c.costField){
                columns.push(c);
            }
        });

        return columns;
    },
    /**
     * This function is called from the FieldPicker plugin to update the displayed fields
     * In the Gridboard, this calls the reconfigureWithColumns function on the TreeGrid
     * @param fields
     */
    updateFields: function(fields){
        //Strip out the tree field and the rank field because those will be automatically added.
        var grid = this.getGrid(),
            new_fields = Ext.Array.filter(fields, function(f){
                var columnName = f.get('name').toLowerCase();

                if (grid.store.enableHierarchy && columnName === grid.treeColumnDataIndex.toLowerCase()) {
                    return false;
                }

                if (grid.enableRanking && columnName === grid.rankColumnDataIndex.toLowerCase()) {
                    return false;
                }
                return true;
        });

        this.fireEvent('updatefields',new_fields);
        //
        //var grid = this.getGrid();
        //
        //this.columnCfgs = this.getGrid()._mergeColumnConfigs(fields, this.columns);

        //var fetchConfig = this.getGrid().getStore().fetch || [];
        //
        //    if (fetchConfig === true) {
        //        return fetchConfig;
        //    }
        //
        //    var fetchFields = Ext.create('Rally.ui.grid.data.ColumnFetchBuilder').build({
        //        grid: this,
        //        columns: this.columns,
        //        fetch: fetchConfig
        //    });
        //
        //    return _.union(fetchFields, [this.treeColumnDataIndex]);


      //  this._addGrid();
        //var gridOrBoard = this.cmp.getGridOrBoard();
        //gridOrBoard.reconfigureWithColumns(fields, false, suspendLoad);

        //this.getGrid().reconfigureWithColumns(fields, false, suspendLoad);

        //columnCfgs = grid._getStatefulColumns(fields);
        //
        ////Always use the old configuration if we have it.
        //fieldscolumnCfgs = grid._mergeColumnConfigs(columnCfgs, this.columns);
        //
        //columnCfgs = Ext.Array.merge(columnCfgs, this.gridConfig.customColumns || []);
        //
        //console.log('columnCfgs', columnCfgs);
        //
        //grid.columnCfgs = columnCfgs;

    },
    updateStore: function(store){
        this.gridConfig.store = store;
        this._addGrid();
    },
    _getGridConfig: function () {
        var context = this.getContext() || Rally.environment.getContext(),
            columnCfgs = Ext.Array.merge(this.gridConfig.columnCfgs || [], this.gridConfig.customColumns || []),
            config = Ext.merge({
                xtype: 'rallytreegrid',
                context: context,
                enableRanking: context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled,
                defaultSortToRank: true,
                enableBlockedReasonPopover: true,
                //stateId: this.stateId + '-grid',
                //stateful: true,
                height: this.getAvailableGridBoardHeight()
            }, this.gridConfig);

            config.columnCfgs = columnCfgs;

        if (_.isEmpty(config.store)) {
            Ext.Error.raise('No grid store configured');
        }
        return config;
    },
    _getConfiguredFilters: function (extraFilters, types) {
        var filters = _.compact(Ext.Array.merge(
            this.getGrid().store.filters,
            this.storeConfig && this.storeConfig.filters,
            this.gridConfig && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
            extraFilters));


        console.log('_getConfiguredFilters',filters.toString(),
            _.isFunction(this.getModels()[0].getArtifactComponentModel));

        // don't do this if not artifact model or we are using filter collection
        //if ( _.isFunction(this.getModels()[0].getArtifactComponentModel)) {
        //    filters = Rally.util.Filter.removeNonapplicableTypeSpecificFilters(filters, types, this.getModels()[0]);
        //}
        console.log('_getConfiguredFilters', filters.toString);
        return filters;
    },
    _addGrid: function () {
        if (this.getGrid()){
            this.getGrid().destroy();
        }

        var grid = this.add(this._getGridConfig());
        this.mon(grid, 'afterproxyload', this._onGridLoad, this);
        if (this.currentCustomFilter) {
            this._applyGridFilters(grid, this.currentCustomFilter);
        }
       return grid;
    },
    _applyGridFilters: function (grid, filterObj) {
        if (!_.isEmpty(filterObj.types)) {
            grid.store.parentTypes = filterObj.types;
        }
        grid.store.clearFilter(true);
        console.log('applied filters', this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
        grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
    },
    _onGridLoad: function () {
        this.fireEvent('load', this);

        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    }

});
                Ext.define('PortfolioItemCostTracking.Utilities',{
    singleton: true,
    isPortfolioItem: function(type){
        var portfolioItemRegExp = new RegExp('^portfolioitem/',"i");
        return portfolioItemRegExp.test(type);
    },
    fetchExportData: function(rootModel, rootFilters, fetch, columns){
        var deferred = Ext.create('Deft.Deferred');
        var recordCounter = 0;
        var rootFetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.getPortfolioItemFetch());

        PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords(rootModel, rootFilters || [], rootFetch).then({
            scope: this,
            success: function(records){
                console.log('fetchExportData success', records);
                var recordTotal = records.length;

                var oids = _.map(records, function(r){ return r.get('ObjectID'); });

                var rollupData = Ext.create('PortfolioItemCostTracking.RollupData',{
                    fetch: fetch,
                    listeners: {
                        scope: this,
                        dataUpdated: function(data){
                            console.log('dataUpdated', data, recordCounter, recordTotal);
                            recordCounter++;
                            if (recordCounter == recordTotal){
                                var exportData = rollupData.getExportableRollupData(oids,columns);
                                var csv = exportData;
                                deferred.resolve(csv);
                            }
                        },
                        error: function(msg){
                            console.log('error',msg);
                        }
                    }
                });

                _.each(records, function(r) {
                    rollupData.setRollupData(r);
                }, this);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    }
});



            Rally.launchApp('PortfolioItemCostTracking', {
                name:"portfolio-item-cost-tracking",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
.lbl {
  text-transform: uppercase;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 10px;
}
.x-form-trigger-wrap {
  margin-top: 0px!important;
}

    </style>
</head>
<body>
</body>
</html>
