<!DOCTYPE html>
<html>
<head>
    <title>portfolio-item-cost-tracking</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('PortfolioItemCostTracking', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    defaults: {
        startDate: new Date('2015-06-01'),
        endDate: new Date('2016-05-31'),
        groupByRelease: false
    },

    config: {
        defaultSettings: {
            selectedCalculationType: 'points',
            normalizedCostPerUnit: 1000,
            projectCostPerUnit: {},
            currencySign: '$'
        }
    },

    items: [],

    portfolioItemRollupData: {},

    launch: function() {

        //ToDO: check for RPM?

        //Initialize the filter values...
        var state = Ext.state.Manager.get(this.getContext().getScopedStateId('cb-type')),
            state_val = state ? state.value : null;


       Deft.Promise.all([
            PortfolioItemCostTracking.WsapiToolbox.fetchPortfolioItemTypes(),
            PortfolioItemCostTracking.WsapiToolbox.fetchDoneStates(),
            PortfolioItemCostTracking.WsapiToolbox.fetchModelTypePathByTypeDefinition(state_val)
        ]).then({
            scope: this,
            success: function(results){
                this.portfolioItemTypes = results[0];
                this._initializeSettings(this.getSettings(), results[1]);
                this._createPickers();
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: msg});
            }
        });
    },
    _createPickers: function(){

        this.fixedHeader = Ext.create('Ext.container.Container',{
            itemId: 'header-controls',
            width: 460,
            height: 50,
            layout: 'hbox',
            padding: '0 0 20 20',
            margin: 10,
            items: [{
                xtype: 'rallydatefield',
                itemId: 'dt-start',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('dt-start'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                value: this.defaults.startDate,
                padding: 5,
                fieldLabel: 'Start Date',
                labelSeparator: '',
                labelCls: 'lbl',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: this.updateStoreFilters
                }
            },{
                xtype: 'rallydatefield',
                itemId: 'dt-end',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('dt-end'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                labelSeparator: '',
                labelCls: 'lbl',
                value: this.defaults.endDate,
                fieldLabel: 'End Date',
                labelAlign: 'top',
                listeners: {
                    scope: this,
                    change: this.updateStoreFilters
                }
            },{
                xtype: 'rallyportfolioitemtypecombobox',
                itemId: 'cb-type',
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('cb-type'),
                //stateEvents: ['change'],
                margin: '0 10 0 0',
                fieldLabel: 'Portfolio Item Type',
                labelAlign: 'top',
                labelCls: 'lbl',
                listeners: {
                    scope: this,
                    ready: function (picker) {
                        console.log('ready');
                    }
                }
            }]
        });
        this.fixedHeader.down('#cb-type').on('change', this._onTypeChange, this);
    },
    _onTypeChange: function(piPicker){
        var piType = piPicker.getRecord().get('TypePath');
        this.modelNames = [piType];
        this._initializeGrid(this.modelNames);
    },
    _initializeSettings: function(settings, doneScheduleStates){

        PortfolioItemCostTracking.Settings.notAvailableText = "--";
        PortfolioItemCostTracking.Settings.currencySign = settings.currencySign;
        PortfolioItemCostTracking.Settings.currencyPrecision = 0;
        PortfolioItemCostTracking.Settings.currencyEnd = false;
        if (doneScheduleStates){
            PortfolioItemCostTracking.Settings.completedScheduleStates = doneScheduleStates;
        }

        PortfolioItemCostTracking.Settings.normalizedCostPerUnit = settings.normalizedCostPerUnit;

        var project_cpu = settings.projectCostPerUnit || {};
        if (!Ext.isObject(project_cpu)){
            project_cpu = Ext.JSON.decode(project_cpu);
        }
        PortfolioItemCostTracking.Settings.projectCostPerUnit = project_cpu;

        PortfolioItemCostTracking.Settings.selectedCalculationType = settings.calculationType || 'points';
    },

     _initializeGrid: function(modelNames){
        var me = this;

        if (this.rollupData){
            this.rollupData.clearRollupData();
        }

        if (this.down('treegridcontainer')){
            if (this.fixedHeader && this.fixedHeader.rendered) {
                var parent = this.fixedHeader.up();
                if(parent && parent.remove){
                    parent.remove(this.fixedHeader, false);
                }
            }
            this.down('treegridcontainer').destroy();
        }

        var filters = this._getDateFilters();
        console.log('filters', filters.toString());
        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            filters: filters,
            fetch: ['FormattedID','Name','Project','PreliminaryEstimate','PlanEstimate','PercentDoneByStoryPlanEstimate','AcceptedLeafStoryPlanEstimateTotal','LeafStoryPlanEstimateTotal','Children','ToDo','Actuals'],
            enableHierarchy: true,
            listeners: {
                scope: this,
                load: this._setRollupData
            }
        }).then({
            scope: this,
            success: function(store) {

                store.model.addField({name: '_rollupDataPreliminaryBudget', type: 'auto', defaultValue: null, displayName: 'Preliminary Budget'});
                store.model.addField({name: '_rollupDataTotalCost', type: 'auto', defaultValue: null, displayName: 'Total Cost'});
                store.model.addField({name: '_rollupDataRemainingCost', type: 'auto', defaultValue: null, displayName: 'Remaining Cost'});
                store.model.addField({name: '_rollupDataActualCost', type: 'auto', defaultValue: null, displayName: 'Actual Cost'});
                store.model.addField({name: '_rollupDataToolTip', type: 'string', defaultValue: null});

                this._updateDisplay(store, modelNames);
            }
        });
    },
    getStartDate: function(){
        return this.getDate('dt-start',this.defaults.startDate);
    },
    getEndDate: function(){
        return this.getDate('dt-end',this.defaults.endDate);
    },
    getDate: function(itemId, defaultDate){
        var dt = defaultDate,
            cmpId = '#' + itemId;

        if (this.down(cmpId)){
            dt = this.down(cmpId).getValue();
        } else {
            var state = Ext.state.Manager.get(this.getContext().getScopedStateId(itemId));
            if (state && state.value){
                dt = new Date(state.value);
            }
        }
        return dt;
    },
    addHeader: function (gb) {
        var header = gb.getHeader();

        if (header) {
            header.getLeft().add(this.fixedHeader);
        }
    },
    _showExportMenu: function (button) {
        console.log('export');
    },
    _getDateFilters: function(){

        var start_date = this.getStartDate(),
            end_date = this.getEndDate();

        var filter_actual = [{
            property: 'ActualEndDate',
            operator: '>=',
            value: Rally.util.DateTime.toIsoString(start_date)
        },{
            property: 'ActualEndDate',
            operator: '<',
            value: Rally.util.DateTime.toIsoString(end_date)
        }];
        filter_actual = Rally.data.wsapi.Filter.and(filter_actual);

        var filter_planned = [{
            property: 'ActualEndDate',
            value: null
        },{
            property: 'PlannedEndDate',
            operator: '<',
            value: Rally.util.DateTime.toIsoString(end_date)
        },{
            property: 'PlannedEndDate',
            operator: '>=',
            value: Rally.util.DateTime.toIsoString(start_date)
        }];
        filter_planned = Rally.data.wsapi.Filter.and(filter_planned);

        return filter_actual.or(filter_planned);
    },
    updateStoreFilters: function(){
        if (this.down('treegridcontainer')){
            this.down('treegridcontainer').storeConfig.filters = this._getDateFilters();
            this.down('treegridcontainer').applyCustomFilter(this.down('treegridcontainer').currentCustomFilter);
        }
    },
    _setRollupData: function(store, node, records, success){
         var rollup_data = this.rollupData;
        console.log('_setrollupData', store, node, records.length, success);
        if (!rollup_data) {
            this.rollupData = Ext.create('PortfolioItemCostTracking.RollupData',{
                portfolioItemTypes: this.portfolioItemTypes
            });
            rollup_data = this.rollupData;
        }

        _.each(records, function(r) {
            rollup_data.setRollupData(r);
            r.set('cls','treeItem');
        }, this);

    },
    _updateDisplay: function(store, modelNames){
        var me = this;

        this.add({
            xtype: 'treegridcontainer',
            context: this.getContext(),

            gridConfig: {
                columnCfgs: this._getColumnCfgs(),
                customColumns: this._getCustomColumns(),
                store: store
            //    stateId: this.getContext().getScopedStateId('cost-grid-test11'),
            //    stateful: true
            },
            plugins:[{
                ptype: 'treegridcontainercustomfiltercontrol',
                filterControlConfig: {
                    modelNames: modelNames,
                    //stateful: true,
                    //stateId: this.getContext().getScopedStateId('cost-grid-filter'),
                    margin: '15px 10px 0px 0px'
                },
                showOwnerFilter: true,
                ownerFilterControlConfig: {
                    //stateful: true,
                    //stateId: this.getContext().getScopedStateId('cost-grid-owner-filter'),
                    margin: '15px 10px 0px 0px'
                }
            },{
                ptype: 'treegridcontainerfieldpicker',
                headerPosition: 'left',
                modelNames: modelNames,
                alwaysSelectedFields: ['_rollupDataPreliminaryBudget','_rollupDataTotalCost','_rollupDataRemainingCost','_rollupDataActualCost'],
                //stateful: true,
                //stateId: this.getContext().getScopedStateId('cost-grid-field-picker'),
                margin: '15px 0px 10px 10px'
            },{
                ptype: 'rallygridboardactionsmenu',
                menuItems: [
                    {
                        text: 'Export...',
                        handler: me._showExportMenu,
                        scope: me
                    }
                ],
                buttonConfig: {
                    iconCls: 'icon-export',
                    margin: '15px 10px 0px 0px'
                }
            }],
            listeners: {
                beforerender: function(gb){
                    this.addHeader(gb);
                },
                scope: this
            },
            height: this.getHeight()
        });
    },
    _getCustomColumns: function(){
        return [{
            text: "Actual Cost To Date",
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataActualCost'
        },{
            text: "Remaining Cost",
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataRemainingCost'
            //dataIndex: '_rollupDataPreliminaryBudget',
        }, {
            text: 'Total Projected',
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataTotalCost'
        },{
            text: 'Preliminary Budget',
            align: 'right',
            xtype: 'costtemplatecolumn',
            costField: '_rollupDataPreliminaryBudget'
        }];
    },
    _getColumnCfgs: function(){

        return [{
            dataIndex: 'Name',
            text: 'Name',
            flex: 5
        },{
            dataIndex: 'Project',
            text: 'Project',
            editor: false
        },{
            dataIndex: 'PlanEstimate',
            text: 'Plan Estimate'
        }, {
            dataIndex: 'PercentDoneByStoryPlanEstimate',
            text: '% Done by Story Points'
        }];
    },
    getSettingsFields: function() {
        return PortfolioItemCostTracking.Settings.getFields(this.getSettings());
    },
    onSettingsUpdate: function (settings){
        this._initializeSettings(settings);
        this._initializeGrid(this.modelNames);
    }
});

                Ext.define('PortfolioItemCostTracking.Settings', {
    singleton: true,

    /**
     * App Settings
     */
    selectedCalculationType: undefined,
    /**
     * Currency display settings to pass into the Ext.util.Format currency function
     */
    currencySign: '$',
    currencyPrecision: 0,
    currencyEnd: false,

    normalizedCostPerUnit: 1,
    projectCostPerUnit: {},

    /**
     * App configurations
     */

    calculationTypes: {
        points: {
            key: 'points',
            label: 'Based on Story Points',
            displayName: 'Story Points',
            defaultColumns: ['Name', 'Project', 'PlanEstimate', 'LeafStoryPlanEstimateTotal'],
            additionalStoryFetch: ['PlanEstimate'],
            actualUnitsForStoryFn: function(data){
                if (data.PlanEstimate && Ext.Array.contains(PortfolioItemCostTracking.Settings.completedScheduleStates, data.ScheduleState)) {
                    return data.PlanEstimate;
                }
                return 0;
            },
            totalUnitsForStoryFn: function(data){
                return data.PlanEstimate || 0;
            }
        },
        taskHours: {
            key: 'taskHours',
            displayName: 'Task Actuals',
            label: 'Based on Task Actuals',
            defaultColumns: ['Name','Project'],
            additionalStoryFetch: ['TaskEstimateTotal','TaskActualTotal','TaskRemainingTotal'],
            actualUnitsForStoryFn: function(data){ return data.TaskActualTotal || 0; },
            totalUnitsForStoryFn: function(data){
                return (data.TaskActualTotal || 0) + (data.TaskRemainingTotal || 0);
            },
            actualUnitsForTaskFn: function(data){
                return data.Actuals || 0;
            },
            totalUnitsForTaskFn: function(data){
                return (data.ToDo || 0) + (data.Actuals || 0);
            }
        },
        timesheets: {
            key: 'timesheets',
            displayName: 'Time Spent',
            label: 'Based on Timesheets',
            defaultColumns: ['Name','Project'],
            additionalStoryFetch: [],
            disabled: true,
            actualUnitsForStoryFn: function(data){ return 0; },
            actualUnitsForTaskFn: function(data){ return 0; },
            totalUnitsForStoryFn: function(data){  return 0; },
            totalUnitsForTaskFn: function(data){  return 0; }
        }
    },

    portfolioItemFetch: ['ObjectID','Parent','Children','UserStories','PreliminaryEstimate','Value'],
    storyFetch: ['ObjectID','Project','ScheduleState','PortfolioItem'],

    notAvailableText: '--',

    completedScheduleStates: [],

    currencyData: [
        {name: "US Dollars", value: "$"},
        {name: "Euro", value: "&#128;"},
        {name: "Japanese Yen", value: "&#165;"},
        {name: "Brazilian Real", value: "R$"}
    ],

    getCalculationTypeSettings: function(){
        return PortfolioItemCostTracking.Settings.calculationTypes[PortfolioItemCostTracking.Settings.selectedCalculationType] || PortfolioItemCostTracking.Settings.calculationTypes.points;
    },
    getCalculationTypeDisplayName: function(){
        return PortfolioItemCostTracking.Settings.getCalculationTypeSettings().displayName || 'Unknown';
    },
    formatCost: function(cost){
        return Ext.util.Format.currency(cost,
            PortfolioItemCostTracking.Settings.currencySign,
            PortfolioItemCostTracking.Settings.currencyPrecision,
            PortfolioItemCostTracking.Settings.currencyEnd);
    },
    getCostPerUnit: function(project_ref){
        return PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref] || PortfolioItemCostTracking.Settings.normalizedCostPerUnit;
    },

    isProjectUsingNormalizedCost: function(project_ref){
        if (PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref]){
            return false;
        }
        return true;
    },
    getStoryFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }
        fetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.storyFetch);

        fetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.getCalculationTypeSettings().additionalStoryFetch);
        return fetch;
    },
    getPortfolioItemFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }
        return Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.portfolioItemFetch);
    },

    getFields: function(config) {

        var current_calculation_type = (config && config.selectedCalculationType) || 'points',
            current_project_costs = (config && config.projectCostPerUnit) || {};

        var currency_store = Ext.create('Rally.data.custom.Store', {
            data: PortfolioItemCostTracking.Settings.currencyData
        });
        var labelWidth = 100;

        var cost_items = [];
        _.each(PortfolioItemCostTracking.Settings.calculationTypes, function(obj, key){
            cost_items.push({
                boxLabel: obj.label || key,
                name: 'selectedCalculationType',
                inputValue: key,
                disabled: obj.disabled || false,
                checked: key === current_calculation_type
            });
        });

        return [{
            xtype: 'rallycombobox',
            name: 'currencySign',
            store: currency_store,
            displayField: 'name',
            valueField: 'value',
            fieldLabel:  'Currency',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Calculate Cost',
            columns: 1,
            vertical: true,
            labelWidth: labelWidth,
            margin: '10 0 10 0',
            items: cost_items
        },{
            xtype: 'rallytextfield',
            name: 'normalizedCostPerUnit',
            fieldLabel: 'Normalized Cost Per Unit',
            labelWidth: labelWidth,
            width: 200,
            margin: '25 0 0 0'
        },{
            xtype: 'costperprojectsettings',
            name: 'projectCostPerUnit',
            fieldLabel: 'Optionally define costs per unit for individual teams (exceptions to the normalized cost)',
            labelAlign: 'top',
            margin: '25 0 0 0',
           // value: current_project_costs,
            readyEvent: 'ready'
        }];
    }
});
                Ext.define('PortfolioItemCostTracking.WsapiToolbox', {
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchModelTypePathByTypeDefinition: function(typeDef){
        var deferred = Ext.create('Deft.Deferred');
        var typeDefId = 0;
        if (typeDef){
            typeDefId = typeDef.replace('/typedefinition/','');
        }

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            fetch: ['TypePath','Name'],
            filters: [{
                property: 'ObjectID',
                value: typeDefId
            }]
        }).load({
            callback: function(records, operation, success){
                if (success && records && records.length > 0){
                    deferred.resolve(records[0].get('TypePath'));
                } else {
                    deferred.resolve(null); //(Ext.String.format("Error getting TypeDefinition for {1}: {0}", operation.error.errors.join(','), typeDef));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec === null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        return deferred;
    },
    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'TypeDefinition',
            fetch: ['TypePath', 'Ordinal'],
            filters: [{
                property: 'TypePath',
                operator: 'contains',
                value: 'PortfolioItem/'
            }],
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }]
        });
        store.load({
            callback: function(records, operation, success){
                if (success){
                    var portfolioItemTypes = new Array(records.length);
                    _.each(records, function(d){
                        //Use ordinal to make sure the lowest level portfolio item type is the first in the array.
                        var idx = Number(d.get('Ordinal'));
                        portfolioItemTypes[idx] = d.get('TypePath');
                        //portfolioItemTypes.reverse();
                    });
                    deferred.resolve(portfolioItemTypes);
                } else {
                    var error_msg = '';
                    if (operation && operation.error && operation.error.errors){
                        error_msg = operation.error.errors.join(',');
                    }
                    deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                }
            }
        });
        return deferred.promise;
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') == "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});

                Ext.define('PortfolioItemCostTracking.CostPerProjectSettings',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.costperprojectsettings',
    config: {
        value: undefined,
        decodedValue: {}
    },
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){

        this.callParent();
        this.addEvents('ready');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name'],
            context: {
                project: null
            },
            limit: 'Infinity'
        });
        store.load({
            scope: this,
            callback: this._buildProjectGrid
        });

    },

    _buildProjectGrid: function(records, operation, success){

        var decodedValue = {};

        if (this.value && !_.isEmpty(this.value)){
            if (!Ext.isObject(this.value)){
                decodedValue = Ext.JSON.decode(this.value);
            } else {
                decodedValue = this.value;
            }
            console.log('decodedValue',decodedValue);
        }

        var data = [],
            empty_text = "No exceptions";

        if (success) {
            _.each(records, function(project){
                var cost = decodedValue[project.get('_ref')] || null;
                if (cost){
                    data.push({projectRef: project.get('_ref'), projectName: project.get('Name'), cost: cost});
                }
            });
        } else {
            empty_text = "Error(s) fetching Project data: <br/>" + operation.error.errors.join('<br/>');
        }

        var custom_store = Ext.create('Ext.data.Store', {
            fields: ['projectRef', 'projectName', 'cost'],
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
           // showRowActionsColumn: false,
            showPagingToolbar: false,
            store: custom_store,
            maxHeight: 300,
            margin: '20 0 0 0',
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        var width = Math.max(this.inputEl.getWidth(true),300);

        Ext.create('Rally.ui.Button',{
            text: 'Select Projects',
            renderTo: this.inputEl,
            margin: '10 0 0 0',
            listeners: {
                scope: this,
                click: function(){

                    Ext.create('ProjectPickerDialog',{
                        autoShow: true,
                        maxHeight: 400,
                        maxWidth: 400,
                        width: Math.min(width, 400),
                        title: 'Choose Project',
                        selectedRefs: _.pluck(data, 'projectRef'),
                        listeners: {
                            scope: this,
                            itemschosen: function(items){
                                var new_data = [],
                                    store = this._grid.getStore();

                                _.each(items, function(item){
                                    if (!store.findRecord('projectRef',item.get('_ref'))){
                                        new_data.push({
                                            projectRef: item.get('_ref'),
                                            projectName: item.get('Name'),
                                            cost: null
                                        });
                                    }
                                });
                                this._grid.getStore().add(new_data);
                            }
                        }
                    });
                }
            }
        });

       this.fireEvent('ready', true);
    },
    _removeProject: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            scope: this,
            rowActionsFn: function(record){
                return  [
                    {text: 'Remove', record: record, handler: me._removeProject, grid: me._grid }
                ];
            },
            //Need to override this since we are using a custom store
            _renderGearIcon: function(value, metaData, record) {
                return '<div class="row-action-icon icon-gear"/>';
            }
        },{
                text: 'Project',
                dataIndex: 'projectRef',
                flex: 1,
                editor: false,
                renderer: function(v, m, r){
                    return r.get('projectName');
                },
                getSortParam: function(v,m,r){
                    return 'projectName';
                }
        },{
            text: 'Cost Per Unit',
            dataIndex: 'cost',
            editor: {
                xtype: 'rallynumberfield'
            },
            renderer: function(v){
                if (v && v > 0){
                    return v;
                }
                return "Use Default";
            }
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {};
        var store = this._grid.getStore();

        store.each(function(record) {
            if (record.get('cost') && record.get('projectRef')) {
                mappings[record.get('projectRef')] = record.get('cost');
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});

                Ext.define('PortfolioItemCostTracking.RollupData',{
    mixins: {
        observable: 'Ext.util.Observable'
    },
    data: {},

    keyField: 'ObjectID',
    portfolioItemTypes: undefined,

    constructor: function(config){
        this.portfolioItemTypes = _.map(config.portfolioItemTypes, function(p){return p.toLowerCase();});
        this.mixins.observable.constructor.call(this, config);
        this.addEvents(
            'dataUpdated',
            'error'
        );
    },
    /**
     * Clears out the data in the tree (called if settings are updated/changed, etc
     */
    clearRollupData: function(key){
        if (key){
            //Just clear this item
            this.data[key] = null;
        } else {
            //Clear everything
            this.data = {};
        }
    },
    setRollupData: function(record){
        var rollup_data = this.data[record.get(this.keyField)] || null;

        if (rollup_data){
            //If we already loaded the data, then use that, we don't want to take the time to reload.
            this._setDataOnModel(record, rollup_data);
            return;
        }
        this._buildRollupData(record);
    },
    _buildRollupData: function(record){
        console.log('_buildRollupData',record.get('FormattedID'),record);

        var key = record.get(this.keyField);
        this.data[key] = this._getDataObj(record.getData(), record.get('_type'));

        if (record.get('UserStories')){
            this._fetchTopLevelUserStories([key]).then({
                scope: this,
                success: function(){
                    console.log('_buildRollupData._fetchTopLevelUserStories success', this.data);
                    this._calculateRollupData(key);
                    this._setDataOnModel(record, this.data[key]);
                },
                failure: function(operation){
                    console.log('_buildRollupData._fetchTopLevelUserStories failure', operation);
                }
            });
            return;
        }


        if (this._isPortfolioItem(record.get('_type')) &&
            record.get('Children') && record.get('Children').Count > 0){
            var child_model_type = this._getChildPortfolioModelType(record.get('_type'));
            this._fetchChildPortfolioItems(child_model_type, [key]).then({
                scope: this,
                success: function(){
                    console.log('_buildRollupData._fetchChildPortfolioItems success', this.data);
                    this._calculateRollupData(key);
                    this._setDataOnModel(record, this.data[key]);
                },
                failure: function(operation){
                    console.log('_buildRollupData._fetchChildPortfolioItems failure', operation);
                }
            });
        } else {
            console.log('_buildRollupData else', record);
            this._calculateRollupData(key);
            this._setDataOnModel(record, this.data[key]);
        }
    },
    _getDataObj: function(data, type){
        return new PortfolioItemCostTracking.RollupDataItem({
           data: data,
            type: type
        });
    },
    _isPortfolioItem: function(type){
        var portfolioItemRegExp = new RegExp('^portfolioitem/',"i");
        return portfolioItemRegExp.test(type);
    },
    _calculateRollupData: function(key){
        var data = this.data[key] || null;
        console.log('_calculateRollupData key, data, this.data',key, data, this.data);
        if (data && this._isPortfolioItem(data.type)){
            console.log('data', data.data.FormattedID);
            if (data.type.toLowerCase() === this.portfolioItemTypes[0].toLowerCase()){
                data.calculateRollupFromChildren();
                console.log('--data', data,  data.projects);
            } else {
                data.totalCost = 0;
                data.actualCost = 0;
                data.remainingCost = 0;
                data.projects = [];
                _.each(data.children, function(c){
                    var child_key = c[this.keyField];
                    this._calculateRollupData(child_key);
                    var child_data = this.data[child_key];
                    data.totalCost += child_data.totalCost ;
                    data.actualCost += child_data.actualCost;
                    data.remainingCost += child_data.remainingCost;
                    data.projects = Ext.Array.merge(data.projects, child_data.projects || []);
                }, this);
            }
        }
    },


    _setDataOnModel: function(record, data){
        record.set('_rollupDataPreliminaryBudget', data.preliminaryBudget);
        record.set('_rollupDataTotalCost',data.totalCost);
        record.set('_rollupDataActualCost',data.actualCost);
        record.set('_rollupDataRemainingCost', data.remainingCost);
        record.set('_rollupDataToolTip', data.getTooltip() || null);
        console.log('set Record', data.data.FormattedID, data);

    },
    _getChildPortfolioModelType: function(portfolioItemType){
        var found = Ext.Array.filter(this.portfolioItemTypes, function(item){
            return item.toLowerCase() === portfolioItemType.toLowerCase();
        });


        if (found && found.length > 0){
            var idx = _.indexOf(this.portfolioItemTypes, found[0]);
            if (idx > 0){
                return this.portfolioItemTypes[idx-1].toLowerCase();
            }
        }
        return null;
    },
    _fetchChildPortfolioItems: function(portfolioItemType, portfolioItemObjectIDs){

        var portfolioItemFetch = PortfolioItemCostTracking.Settings.getPortfolioItemFetch(); //['ObjectID','Parent','Children','UserStories','PreliminaryEstimate','Value'];
        var filters = _.map(portfolioItemObjectIDs, function(poid){
            return {
                property: 'Parent.ObjectID',
                value: poid
            };
        });
        filters = Rally.data.wsapi.Filter.or(filters);
        console.log('_fetchChildPortfolioItems',portfolioItemType, filters);

        return PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords(portfolioItemType,filters,portfolioItemFetch,{project: null}).then({
            scope: this,
            success: function(records){

                var child_model_type = this._getChildPortfolioModelType(portfolioItemType);
                _.each(records, function(r){
                    if (r.get('Parent') && r.get('Parent').ObjectID){
                        var parent = r.get('Parent').ObjectID;
                        this.data[parent].addChild(r.getData());
                        console.log(this.data[parent].children.length);
                    }
                    var obj_id = r.get('ObjectID');
                    this.data[obj_id] = this._getDataObj(r.getData(),portfolioItemType);
                }, this);

                var obj_ids = _.map(records, function(r){return r.get('ObjectID');});
                if (records.length > 0 && child_model_type){
                    return this._fetchChildPortfolioItems(child_model_type, obj_ids);
                } else {
                    return this._fetchTopLevelUserStories(obj_ids);
                }
            }
        });
    },
    _fetchTopLevelUserStories: function(portfolioItemObjectIDs){
        var deferred = Ext.create('Deft.Deferred');

        if (portfolioItemObjectIDs.length === 0){
            deferred.resolve();
        }

        var filters = _.map(portfolioItemObjectIDs, function(pi_oid){
            return {
                property: 'PortfolioItem.ObjectID',
                value: pi_oid
            };
        });
        filters = Rally.data.wsapi.Filter.or(filters);
        var storyFetch = PortfolioItemCostTracking.Settings.getStoryFetch();
        PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords('HierarchicalRequirement',filters,storyFetch,{project: null}).then({
            scope: this,
            success: function(records){
                _.each(records, function(r){
                    if (r.get('PortfolioItem') && r.get('PortfolioItem').ObjectID){
                        var obj_id = r.get('PortfolioItem').ObjectID;
                        this.data[obj_id].addChild(r.getData());
                        console.log('adding children', this.data[obj_id].children.length);
                        this.data[r.get('ObjectID')] = this._getDataObj(r.getData(), r.get('_type'));
                    }
                }, this);
                console.log('data', this.data);
                deferred.resolve();
            },
            failure: function(operation){
                console.log('_fetchTopLevelUserStories failed', operation);
                deferred.reject(operation);
            }
        });
        return deferred;
    }
});
                Ext.define('PortfolioItemCostTracking.RollupDataItem',{

    children: undefined,
    type: undefined,

    totalUnits: null,
    actualUnits: null,
    preliminaryBudget: null,
    actualCost: 0,
    remainingCost: 0,
    totalCost: 0,
    tooltip: undefined,
    projectCosts: undefined,
    /**
     * data is from the record associated with the rollup data
     */
    data: undefined,

    constructor: function(config){
        this.data = config.data;
        this.type = config.type;

        this._updateProjectNameAndCostHash(this.data.Project);

        this.preliminaryBudget = this.calculatePreliminaryBudget(this.data);

        if ((this.type.toLowerCase() === 'hierarchicalrequirement' )||(this.type.toLowerCase() === 'task')){
            this.actualCost = this.calculateActualCost(this.data, this.type.toLowerCase());
            this.totalCost = this.calculateTotalCost(this.data,this.type.toLowerCase());
            this.actualUnits = this.getActualUnits(this.data,this.type.toLowerCase());
            this.totalUnits = this.getTotalUnits(this.data,this.type.toLowerCase());
            if (this.actualCost === null || this.totalCost === null) {
                this.remainingCost = null;
            } else {
                this.remainingCost = this.totalCost - this.actualCost ;
            }
        }
    },
    addChild: function(child){
        if (!this.children){
            this.children = [];
        }
        this.children.push(child);
    },
    calculateRollupFromChildren: function(){

        var noRollups = ['task','hierarchicalrequirement'];
        if (Ext.Array.contains(noRollups, this.type.toLowerCase())){
            return;
        }

        var actual_value = 0,
            total_value = 0,
            actual_units = 0,
            total_units = 0;

        _.each(this.children, function (s) {
            total_value += this.calculateTotalCost(s, 'hierarchicalrequirement');
            actual_value += this.calculateActualCost(s, 'hierarchicalrequirement');
            this._updateProjectNameAndCostHash(s.Project);
            actual_units += this.getActualUnits(s, 'hierarchicalrequirement');
            total_units += this.getTotalUnits(s, 'hierarchicalrequirement');
        }, this);

        this.actualUnits = actual_units;
        this.totalUnits = total_units;

        this.totalCost = total_value;
        this.actualCost = actual_value;
        this.remainingCost = total_value - actual_value;
    },
    getTooltip: function(){
        var actual_units = this.actualUnits === null ? '--' :  this.actualUnits,
            total_units = this.totalUnits === null ? '--' : this.totalUnits;


        var calc_type_name = PortfolioItemCostTracking.Settings.getCalculationTypeDisplayName();

        var html = Ext.String.format('[{0}] completed {1}/{2}<br/><br/>Cost per unit:<br/>', calc_type_name, actual_units, total_units);
        _.each(this.projectCosts, function(project_cost, project_name){
            html += Ext.String.format('{0} {1}<br/>', PortfolioItemCostTracking.Settings.formatCost(project_cost), project_name);
        });

        return html;

    },
    _updateProjectNameAndCostHash: function(project){

        this.projectCosts = this.projectCosts || {};

        var name = project._refObjectName,
            cost = PortfolioItemCostTracking.Settings.getCostPerUnit(project._ref);

        if (PortfolioItemCostTracking.Settings.isProjectUsingNormalizedCost(project._ref)){
            name =  "normalized (default)";
        }
        this.projectCosts[name] = cost;
    },
    calculateActualCost: function(data, modelType){
        var units = this.getActualUnits(data, modelType);
        if (units === null){
            return null;
        }
        return units * PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
    },
    calculateTotalCost: function(data, modelType){

        var units = this.getTotalUnits(data, modelType);
        if (units === null){
            return null;
        }
        return units * PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
    },
    getActualUnits: function(data, modelType){
        var calcType = PortfolioItemCostTracking.Settings.getCalculationTypeSettings(),
            fn = 'actualUnitsForStoryFn';

        if (modelType.toLowerCase() === 'task'){
            fn = 'actualUnitsForTaskFn';
        }

        if (calcType[fn]) {
            return calcType[fn](data);
        }
        return null;
    },
    getTotalUnits: function(data, modelType){
        var calcType = PortfolioItemCostTracking.Settings.getCalculationTypeSettings(),
            fn = 'totalUnitsForStoryFn';

        if (modelType.toLowerCase() === 'task'){
            fn = 'totalUnitsForTaskFn';
        }
        if (calcType[fn]) {
            return calcType[fn](data);
        }
        return null;
    },
    calculatePreliminaryBudget: function(data){

        if (data && data.PreliminaryEstimate && data.PreliminaryEstimate.Value){
            var cpu = PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
            return cpu * data.PreliminaryEstimate.Value;
        }
        return null;
    }
});

                

Ext.define('ProjectPickerDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.projectpickerdialog',


    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemschosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemschosen', this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },
    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }
        Ext.create('Rally.data.wsapi.ProjectTreeStoreBuilder').build({
            models: ['project'],
            autoLoad: true,
            enableHierarchy: true,
            filters: [{
                property: 'Parent',
                value: ""
            }]
        }).then({
            scope: this,
            success: function(store) {

                var mode = this.multiple ? 'MULTI' : 'SINGLE';

                var checkbox_model = Ext.create('Rally.ui.selection.CheckboxModel', {
                    mode: mode,
                    enableKeyNav: false,
                    allowDeselect: true
                });

                this.grid = this.add({
                    xtype: 'rallytreegrid',
                    treeColumnDataIndex: 'Name',
                    treeColumnHeader: 'Name',
                    viewConfig: {
                        cls: 'grid-view-bulk-edit'
                    },
                    enableRanking: false,
                    enableEditing: false,
                    enableBulkEdit: false,
                    shouldShowRowActionsColumn: false,

                    selModel: checkbox_model,
                    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                        store = store.treeStore || store;
                        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('Name')).apply(record.data);
                    },
                    columnCfgs: [],
                    store: store
                });

                this.mon(this.grid, {
                    beforeselect: this._onGridSelect,
                    beforedeselect: this._onGridDeselect,
                    load: this._onGridLoad,
                    scope: this
                });
                this.add(this.grid);
                this._onGridReady();
            }
        });
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);

        console.log('selectionModel',selectionModel, record);

        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }
        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },
    _onGridLoad: function() {
        //console.log('_onGridLoad');
        var store = this.grid.store;
        var records = [];
        _.each(this.selectionCache, function(record) {
            var foundNode = store.getRootNode().findChild('_ref', record.get('_ref'),true);

            if (foundNode) {
                records.push(foundNode);
            }
        });
        if (records.length) {
            this.grid.getSelectionModel().select(records);
        }
    },
    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        //Filter functions call store load so we don't need to refresh the selections becuaes the
        //onGridLoad function will
        if (terms) {
            store.filter([
                Ext.create('Rally.data.wsapi.Filter',{
                    property: 'Name',
                    operator: 'contains',
                    value: terms
                })
            ]);
        } else {
            store.clearFilter();
        }

    },
    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

Ext.override(Rally.data.wsapi.ParentChildMapper, {
    constructor: function() {
        this.parentChildTypeMap = {
            project: [{
                typePath: 'project', collectionName: 'Children', parentField: 'Parent'
            }],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    }
});


Ext.define('Rally.data.wsapi.ProjectTreeStore', {

    // Client Metrics Note: WsapiTreeStore is too low level to record its load begins/ends. The problem is
    // client metrics can only reliably keep track of one load per component at a time. WsapiTreeStore makes
    // no guarantee that only one load will happen at a time. It's better to measure the component that is using
    // the store. All is not lost, the actual data requests that WsapiTreeStore makes *are* measured by client metrics.

    requires: [
        'Deft.promise.Deferred',
        'Rally.data.ModelFactory',
        'Rally.ui.grid.data.NodeInterface',
        'Rally.data.ModelTypes',
        'Rally.data.wsapi.ParentChildMapper'
    ],
    extend: 'Rally.data.wsapi.TreeStore',
    alias: 'store.rallyprojectwsapitreestore',

    /**
     * The type definition typePaths to render as root items (required)
     * @cfg {String[]} parentTypes
     */
    parentTypes: ['project'],

    /**
     * @property
     * @private
     */
    childLevelSorters: [{
        property: 'Name',
        direction: 'ASC'
    }],

    getParentFieldNamesByChildType: function(childType, parentType) {
        var model = this.model; //.getArtifactComponentModel(childType);
        return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
            var typePath = field.typePath,
                fieldName = field.fieldName,
            // hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);
                hasFieldModel = model.hasField(fieldName);

            if (hasFieldModel) {
                acc.push(fieldName.replace(/\s+/g, ''));
            }
        }, [], this);
    },

    filter: function(filters) {
        this.fireEvent('beforefilter', this);
        //We need to clear the filters to remove the Parent filter
        this.filters.clear();
        this.filters.addAll(filters);
        this._resetCurrentPage();
        this.load();
    },

    clearFilter: function(suppressEvent) {
        this._resetCurrentPage();
        this.filters.clear();
        //We need to add the parent filter back in
        this.filters.addAll(Ext.create('Rally.data.wsapi.Filter',{
            property: 'Parent',
            value: ''
        }));

        if (!suppressEvent) {
            this.load();
        }
    }
});

Ext.define('Rally.data.wsapi.ProjectTreeStoreBuilder', {
    extend: 'Rally.data.wsapi.TreeStoreBuilder',

    build: function(config) {
        //A context needs to be passed in here, and it NEEDS to be a DataContext (context.getDataContext())
        //otherwise you will get a bunch of garbage on your WSAPI request

        config = _.clone(config || {});
        config.storeType = 'Rally.data.wsapi.ProjectTreeStore';

        return this.loadModels(config).then({
            success: function(models) {
                models = _.values(models);
                return this._buildStoreWithModels(models, config);
            },
            scope: this
        });
    }
});
                Ext.define('Ext.CostTemplate', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.costtemplatecolumn'],

    tpl: '',
    costField: '',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}">{[this.getCost(values)]}</div></tpl>',{
            costField: me.costField,
            getCost: function(values){
                if (values[this.costField] === null){
                    return PortfolioItemCostTracking.Settings.notAvailableText;
                } else {
                    return PortfolioItemCostTracking.Settings.formatCost(values[this.costField] || 0);
                }
            },
            getTooltip: function(values){
                if (values._rollupDataToolTip){
                    return values._rollupDataToolTip;
                }
                return '';
            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    getValue: function(){

        return this.values[this.costField] || 0;
    },
    defaultRenderer: function(value, meta, record) {

        var data = Ext.apply({}, record.data, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});
        //Ext.define('Rally.ui.grid.TreeGrid', {
        //    alias: 'widget.rallytreegrid',
        //
        //    extend: 'Ext.tree.Panel',
        //    cls: 'rally-grid',
        //
        //    requires: [
        //        'Ext.data.NodeInterface',
        //        'Ext.selection.Model',
        //        'Ext.state.Manager',
        //        'Rally.Message',
        //        'Rally.data.wsapi.TreeStoreBuilder',
        //        'Rally.ui.tree.PagingToolbar',
        //        'Rally.ui.grid.FieldColumnFactory',
        //        'Rally.ui.grid.FormattedIDTreeColumn',
        //        'Rally.ui.grid.ColumnBuilder',
        //        'Rally.ui.grid.RowModel',
        //        'Rally.ui.grid.TreeGridExpandTracker',
        //        'Rally.ui.grid.TreeView',
        //        'Rally.ui.grid.plugin.CellEditing',
        //        'Rally.ui.grid.plugin.CellValidationUi',
        //        'Rally.ui.grid.plugin.ClickHandlerPlugin',
        //        'Rally.ui.grid.plugin.ColorPickerPlugin',
        //        'Rally.ui.grid.plugin.ColumnAutoSizer',
        //        'Rally.ui.grid.plugin.FormattedIDHoverable',
        //        'Rally.ui.grid.plugin.TreeGridChildPager',
        //        'Rally.ui.grid.plugin.TreeGridObjectUpdateListener',
        //        'Rally.ui.grid.plugin.TreeViewDragDrop',
        //        'Rally.ui.grid.plugin.Validation',
        //        'Rally.ui.grid.plugin.ViewVisibilityListener',
        //        'Rally.ui.grid.feature.SummaryRow',
        //        'Rally.ui.grid.data.ColumnFetchBuilder',
        //        'Rally.ui.grid.TreeGridExpandTracker',
        //        'Rally.util.Animation',
        //        'Rally.util.Ref',
        //        'Rally.ui.grid.plugin.BufferedRenderer',
        //        'Rally.ui.grid.plugin.InlineAddRowExpander',
        //        'Rally.realtime.Realtime',
        //        'Rally.realtime.RealtimePlugin'
        //    ],
        //
        //    mixins: {
        //        messageable: 'Rally.Messageable',
        //        stateful: 'Ext.state.Stateful',
        //        filternotifiable: 'Rally.ui.filter.FilterNotifiable',
        //        clientMetrics: 'Rally.clientmetrics.ClientMetricsRecordable',
        //        treeGridRankable: 'Rally.ui.grid.dragdrop.TreeGridRankable'
        //    },
        //
        //    clientMetrics: [
        //        {
        //            beginEvent: 'expandbatch',
        //            endEvent: 'afterexpandbatch',
        //            description: 'expand batch'
        //        },
        //        {
        //            beginEvent: 'collapsebatch',
        //            endEvent: 'aftercollapsebatch',
        //            description: 'collapse batch'
        //        },
        //        {
        //            beginEvent: 'beforeitemcollapse',
        //            endEvent: 'afteritemcollapse',
        //            description: 'item collapse'
        //        },
        //        {
        //            beginEvent: 'beforeitemexpand',
        //            endEvent: 'itemexpand',
        //            description: 'item expand'
        //        }
        //    ],
        //
        //    /**
        //     * @private
        //     * @property
        //     *
        //     * The state that was applied by #applyState.
        //     *
        //     * Saved so plugins that are initialized after state is applied can access state.
        //     */
        //    appliedState: undefined,
        //
        //    config: {
        //        /**
        //         * @cfg {Rally.data.wsapi.TreeStore} (required)
        //         * A TreeStore instance, used to handle state and facilitate hierarchical behavior (enableHierarchy parameter on the store)
        //         * Must specify a store see {@link Rally.data.wsapi.TreeStoreBuilder} for building stores
        //         */
        //        store: undefined,
        //
        //        /**
        //         * @cfg {Object}
        //         * The object to enable displayed when not using collection filtering and there is no data.  Can be html string to be
        //         * inserted into the rendering template for the no data message in the {@link Rally.ui.view.NoData} mixin on the view.
        //         */
        //        noDataHelpLink: undefined,
        //
        //        /**
        //         * @cfg {String}
        //         * An optional item name to display in the no data text. Defaults to 'work item'.
        //         */
        //        noDataItemName: undefined,
        //
        //        /**
        //         * @cfg {Array}
        //         * Accepts {@link Ext.grid.Panel} column configs, or a string to use the default renderer for the type
        //         */
        //        columnCfgs: [],
        //
        //        /**
        //         * @cfg {Boolean}
        //         * True to always display default columns, regardless of save column state.
        //         */
        //        alwaysShowDefaultColumns: false,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * True to use the Buffered Renderer plugin.
        //         */
        //        bufferedRenderer: false,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Automatically add all fields from the Model into the columns list
        //         * Note this only is compatible with an instance of {@link Rally.data.wsapi.Model}
        //         */
        //        autoAddAllModelFieldsAsColumns: false,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Automatically add gear menu column to the grid
        //         */
        //        shouldShowRowActionsColumn: true,
        //
        //        /**
        //         * @cfg {Object}
        //         * Custom config for the row action column
        //         */
        //        rowActionColumnConfig: null,
        //
        //        disableColumnMenus: true,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables the behavior for the blocked reason plugin
        //         */
        //        enableBlockedReasonPopover: true,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables a one-click to change the schedule state
        //         */
        //        enableScheduleStateClickable: true,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables drag drop of rows, persists the rank,
        //         * Uses the {#link Rally.ui.grid.plugin.TreeViewDragDrop} plugin
        //         */
        //        enableRanking: true,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables inline editing of cells,
        //         * Uses the {@link Rally.ui.grid.plugin.CellEditing} plugin
        //         */
        //        enableEditing: true,
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables bulk edit
        //         */
        //        enableBulkEdit: true,
        //
        //        /**
        //         * @cfg {Object}
        //         * Configuration options for the bulk edit menu.
        //         * These properties will be passed to the {Rally.ui.menu.bulk.RecordMenu} on creation
        //         */
        //        bulkEditConfig: {},
        //
        //        lines: false,
        //        /**
        //         * @cfg {Boolean}
        //         * Enables validation icons on a grid,
        //         * Uses the {@link Rally.ui.grid.plugin.Validation} plugin
        //         * and the {@link Rally.ui.grid.plugin.CellValidationUi} plugin
        //         */
        //        enableValidationUi: true,
        //
        //        /**
        //         * @cfg {Object}
        //         * Additional config to pass to the editing plugin, depends on the {@link #enableEditing} flag to be set to true
        //         */
        //        editingConfig: {
        //            publishMessages: true
        //        },
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Enables inline add
        //         */
        //        enableInlineAdd: false,
        //
        //        /**
        //         * @cfg {Object}
        //         * Additional config to pass to the inline add plugin, depends on the {@link #enableInlineAdd} flag to be set to true
        //         */
        //        inlineAddConfig: {
        //
        //        },
        //
        //        plugins: [],
        //
        //        selModel: {
        //            selType: 'rallycheckboxmodel'
        //        },
        //
        //        context: undefined,
        //
        //        rootVisible: false,
        //
        //        viewConfig: {
        //            xtype: 'rallytreeview',
        //            animate: false,
        //            loadMask: false,
        //            forceFit: true,
        //            plugins: [
        //                'rallytreeviewdragdrop',
        //                'rallyviewvisibilitylistener'
        //            ]
        //        },
        //
        //        /**
        //         * @cfg {String}
        //         * This column will contain a cheveron to expand/collapse the row if the row has children.
        //         * This field will be next to the rank column.
        //         */
        //        treeColumnDataIndex: 'FormattedID',
        //
        //        /**
        //         * @cfg {String}
        //         * The label for the treecolumn's header.
        //         */
        //        treeColumnHeader: 'ID',
        //
        //        /**
        //         * @cfg {Boolean}
        //         * Whether the tree column should be resizable
        //         */
        //        treeColumnResizable: false,
        //
        //        treeColumnRenderer: undefined,
        //
        //        /**
        //         * @cfg {String}
        //         * The field to be displayed next to the Expand icon on a tree grid.  Defaults to DragAndDropRank.
        //         */
        //        rankColumnDataIndex: 'DragAndDropRank',
        //
        //
        //        /**
        //         * @cfg {Function} onBeforeRecordMenuEdit
        //         * Function to execute before editing a record from the gear menu. Return false to not perform the action.
        //         * @param {Rally.data.Model} record The record that is being acted on.
        //         */
        //        onBeforeRecordMenuEdit: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onBeforeRecordMenuCopy
        //         * Function to execute before copying a record from the gear menu. Return false to not perform the action.
        //         */
        //        onBeforeRecordMenuCopy: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onRecordMenuCopy
        //         * Function to execute after copying a record from the gear menu.
        //         * @param {Rally.data.Model} copiedRecord The record that is being acted on.
        //         * @param {Rally.data.Model} originalRecord The record that is being acted on.
        //         * @param {Ext.data.Operation} operation The WSAPI operation
        //         */
        //        onRecordMenuCopy: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onBeforeRecordMenuDelete
        //         * Function to execute before deleting a record from the gear menu. Return false to not perform the action.
        //         */
        //        onBeforeRecordMenuDelete: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onRecordMenuDelete
        //         * Function to execute after deleting a record from the gear menu.
        //         */
        //        onRecordMenuDelete: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onBeforeRecordMenuRankHighest
        //         * Function to execute before ranking a record highest from the gear menu. Return false to not perform the action.
        //         * @param {Rally.data.Model} record The record that is being acted on.
        //         */
        //        onBeforeRecordMenuRankHighest: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onBeforeRecordMenuRankLowest
        //         * Function to execute before ranking a record highest from the gear menu. Return false to not perform the action.
        //         * @param {Rally.data.Model} record The record that is being acted on.
        //         */
        //        onBeforeRecordMenuRankLowest: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Function} onRecordMenuRemove
        //         * Function to execute after removing a record from the gear menu.
        //         * @param {Rally.data.Model} record The record that is being acted on.
        //         */
        //        onRecordMenuRemove: Ext.emptyFn,
        //
        //        /**
        //         * @cfg {Array}
        //         * Array of configurations for summary e.g. {field: 'PlanEstimate', type: 'sum', units: 'pt'}
        //         */
        //        summaryColumns: [],
        //
        //        expandTracker: null,
        //
        //        /**
        //         * @cfg {boolean}
        //         * If true, cells will word wrap.  When false, if contents does not fit the cell
        //         * the content will be truncated and ellipsis added to the end.
        //         */
        //        variableRowHeight: true,
        //
        //        expandAllInColumnHeaderEnabled: false
        //    },
        //
        //    constructor: function(config) {
        //        this.mergeConfig(config);
        //
        //        this.treeColumnRenderer = this.treeColumnRenderer || this._defaultTreeColumnRenderer;
        //        this.plugins = this._setupPlugins(config);
        //        this.features = this._setupFeatures(config);
        //
        //        this.callParent(arguments);
        //    },
        //
        //    initComponent: function() {
        //        if (!this.store) {
        //            Ext.Error.raise('A store must be specified in the config');
        //        }
        //
        //        if (!this.expandTracker) {
        //            this.expandTracker = Ext.create('Rally.ui.grid.TreeGridExpandTracker');
        //        }
        //
        //        if (!this.variableRowHeight) {
        //            this.addCls('rally-grid-cell-no-wrap');
        //        }
        //
        //        this.addEvents([
        //        /**
        //         * @event filterchange
        //         * Fires when the grid's filter is changed.
        //         * @param {Ext.util.Filter} filter
        //         * @param Boolean clearFilter - true if existing filters should be cleared before applying new filter
        //         * @param {Boolean} ignoreDefaultFilters True if filters passed in at initialization time should be removed when clearing other filters
        //         */
        //            'filterchange',
        //        /**
        //         * @event
        //         * Fires when user wants all items expanded
        //         * @param {Ext.Component} this
        //         */
        //            'expandall',
        //        /**
        //         * @event
        //         * Fires when user wants all item collapsed
        //         * @param {Ext.Component} this
        //         */
        //            'collapseall',
        //        /**
        //         * @event
        //         * Fires when all items are expanded and after all childern are loaded and rendered
        //         * @param {Ext.Component} this
        //         * @param {Array} expanded nodes
        //         */
        //            'afterexpandbatch',
        //        /**
        //         * @event
        //         * Fires when all items are collapsed and after all childern are rendered
        //         * @param {Ext.Component} this
        //         * @param {Array} collapsed nodes
        //         */
        //            'aftercollapsebatch',
        //        /**
        //         * @event
        //         * Fires after a new child has been added to a parent and rendered.
        //         *
        //         * @param {Ext.Component} this
        //         * @param {Ext.data.Mode} parentNode
        //         * @param {Ext.data.Mode} childNode
        //         */
        //            'afterchildadd'
        //        ]);
        //
        //        this.store.requester = this.store.requester || this;
        //        this.store.clientMetricsParent = this;
        //
        //        if (this.enableBulkEdit) {
        //            this.selType = 'rallycheckboxmodel';
        //            this.selModel = {
        //                injectCheckbox: this.enableRanking ? 1 : 0
        //            };
        //        }
        //
        //        this._applyInitialState();
        //        this._buildDockedItems();
        //        this._buildColumns();
        //        this._applySorters();
        //        this._applyFetch();
        //        this._initView();
        //
        //        this.callParent(arguments);
        //
        //        this.subscribe(Rally.Message.bulkImport, function() {
        //            this.refresh({
        //                callback: function(records, operation, success) {
        //                    this.store.sort();
        //                },
        //                scope: this
        //            });
        //        }, this);
        //    },
        //
        //    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
        //        store = store.treeStore || store;
        //        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('FormattedID')).apply(record.data);
        //    },
        //
        //    _applySorters: function() {
        //        var store = this.store,
        //            sorterConfig,
        //            rankField;
        //
        //        if (store.sorters.getCount() > 0) {
        //            return; // use configured sorters
        //        }
        //
        //        if (Rally.data.Ranker.isRankable(store.model)) {
        //            rankField = Rally.data.Ranker.getRankField(store.model);
        //            sorterConfig = Rally.data.util.Sorter.sorters(rankField + ' ASC').pop();
        //        } else {
        //            sorterConfig = Rally.data.util.Sorter.getDefaultSort(store.model.typePath, {asSorter: true}).pop();
        //        }
        //
        //        store.sorters.add(Ext.create('Ext.util.Sorter', sorterConfig));
        //    },
        //
        //    _applyFetch: function() {
        //        this.store.fetch = this._buildFetch();
        //
        //        if (this._shouldShowSummary()) {
        //            this.store.summaryFields = _.pluck(this.summaryColumns, 'field');
        //        }
        //    },
        //
        //    _addStoreListeners: function() {
        //        this.relayEvents(this.store, [
        //            'load',
        //            'beforeexpand',
        //            'beforecollapse',
        //            'beforeload',
        //            'expand',
        //            'collapse',
        //            'currentpagereset',
        //            'datachanged',
        //            'excludebyfilter',
        //            'movetopage',
        //            'beforefilter',
        //            'afterbuscreate',
        //            'afterbusupdate',
        //            'afterbusremove'
        //        ], 'store');
        //        this.on('storeload', this._onStoreLoad, this);
        //        this.on('storedatachanged', this._onDataChanged, this);
        //        this.on('storeexcludebyfilter', this._onExcludeByFilter, this);
        //        this.on('storemovetopage', this._onMoveToPage, this);
        //        this._initStateEvents();
        //    },
        //
        //    _initPager: function() {
        //        var pager = this.down('#pagingToolbar');
        //
        //        this.relayEvents(pager, ['change', 'beforechange'], 'pagingtoolbar');
        //
        //        this._addPageResetListeners();
        //    },
        //
        //    _initView: function() {
        //        if (!this.rendered) {
        //            this.on('afterrender', this._initView, this, {single: true});
        //            return;
        //        }
        //
        //        this._addStoreListeners();
        //        this._initPager();
        //        this._fireComponentReady();
        //    },
        //
        //    _initStateEvents: function() {
        //        this.on('storeload', function() {
        //            this.readyForStateEvents = true;
        //            this.addStateEvents(['columnresize', 'columnmove', 'sortchange', 'reconfigure', 'pagingtoolbarchange']);
        //            this.recordComponentReady();
        //        }, this, {
        //            single: true,
        //            buffer: 100
        //        });
        //    },
        //
        //    _applyInitialState: function() {
        //        var id = this.getStateId() || '',
        //            state = this.appliedState || Ext.state.Manager.getProvider().get(id) || {};
        //
        //        this.applyState(state);
        //    },
        //
        //    _fireComponentReady: function() {
        //        if (Rally.BrowserTest) {
        //            Rally.BrowserTest.publishComponentReady(this);
        //            this.publish(Rally.Message.treeLoaded);
        //        }
        //    },
        //
        //    destroy: function() {
        //        this._removePageResetListeners();
        //        this.callParent(arguments);
        //    },
        //
        //    refresh: function(options) {
        //        return this.store.load(_.assign({
        //            node: this.getRootNode(),
        //            clearOnLoad: false
        //        }, options));
        //    },
        //
        //    refreshAfterBulkAction: function() {
        //        return Deft.Promise.when(true);
        //    },
        //
        //    _addPageResetListeners: function() {
        //        this.on('storecurrentpagereset', this._resetCurrentPage, this);
        //
        //    },
        //
        //    _removePageResetListeners: function() {
        //        this.un('storecurrentpagereset', this._resetCurrentPage, this);
        //    },
        //
        //    _getColumnCfgs: function() {
        //        return this.columnCfgs;
        //    },
        //
        //    _isStatefulColumn: function(columnName) {
        //
        //        columnName = columnName.toLowerCase();
        //
        //        if (this.store.enableHierarchy && columnName === this.treeColumnDataIndex.toLowerCase()) {
        //            return false;
        //        }
        //
        //        if (this.enableRanking && columnName === this.rankColumnDataIndex.toLowerCase()) {
        //            return false;
        //        }
        //
        //        return true;
        //    },
        //
        //    _getStatefulColumns: function(columnCfgs) {
        //        return _.filter(columnCfgs, function(columnCfg) {
        //            var columnName = Ext.isString(columnCfg) ? columnCfg: columnCfg.dataIndex;
        //
        //            return !Ext.isEmpty(columnName) && this._isStatefulColumn(columnName);
        //        }, this);
        //    },
        //
        //    addStateEvents: function() {
        //        // overridden to ignore state events set before initial load
        //        if (this.readyForStateEvents) {
        //            this.callParent(arguments);
        //        }
        //    },
        //
        //    applyState: function(state) {
        //        this.appliedState = state;
        //        this._applyState(state);
        //    },
        //
        //    _applyState: function(state) {
        //        if (state.columns) {
        //            // make sure flex is set correctly for column configs saved in a preference
        //            _.each(state.columns, this._setColumnFlex, this);
        //            if (this.enableRanking) {
        //                state.columns = this._removeExistingRankColumn(state.columns);
        //            }
        //
        //            this._applyStatefulColumns(state.columns);
        //        }
        //
        //        if (state.pagingToolbar) {
        //            var store = this.getStore();
        //            store.pageSize = state.pagingToolbar.pageSize;
        //            store.currentPage = state.pagingToolbar.currentPage;
        //        }
        //
        //        if (state.sorters) {
        //            var sorters = _.transform(state.sorters, function (collection, sorterState) {
        //                if(Rally.data.Ranker.isRankField(sorterState.property)) {
        //                    sorterState.property = Rally.data.Ranker.getRankField(this.store.model);
        //                }
        //
        //                collection.add(Ext.create('Ext.util.Sorter', {
        //                    property: sorterState.property,
        //                    direction: sorterState.direction
        //                }));
        //            }, Ext.create('Ext.util.MixedCollection'), this);
        //            this.getStore().sorters = sorters;
        //        }
        //
        //        if (state.expandedRowPersistence) {
        //            this.expandedRowPersistenceState = state.expandedRowPersistence;
        //        }
        //
        //        this.fireEvent('staterestore', this, state);
        //    },
        //
        //    _applyStatefulColumns: function(columns) {
        //        if (this.alwaysShowDefaultColumns) {
        //            _.each(this.columnCfgs, function(columnCfg) {
        //                var dataIndex = _.has(columnCfg.dataIndex) ? columnCfg.dataIndex : columnCfg;
        //                if (!_.any(columns, {dataIndex: dataIndex})) {
        //                    columns.push(columnCfg);
        //                }
        //            });
        //        }
        //
        //        this.columnCfgs = columns;
        //    },
        //
        //    _removeExistingRankColumn: function(columns) {
        //        return _.filter(columns, function(col) {
        //            return col.dataIndex !== this.rankColumnDataIndex;
        //        }, this);
        //    },
        //
        //    getState: function() {
        //        var state = {},
        //            statefulColumns = this._getStatefulColumns(this.headerCt.getGridColumns());
        //
        //        state.columns = _.map(statefulColumns, this._getColumnConfigFromColumn, this);
        //
        //        state.pagingToolbar = {
        //            pageSize: this.getStore().pageSize,
        //            currentPage: this.getStore().currentPage
        //        };
        //
        //        state.sorters = _.map(this.getStore().sorters.getRange(), function(sorter) {
        //            return {
        //                property: sorter.property,  //Why does this differ from what is in _initSorters()?
        //                direction: sorter.direction
        //            };
        //        });
        //
        //        state.expandedRowPersistence = this.expandedRowPersistenceState;
        //
        //        return state;
        //    },
        //
        //    // Buffer method to avoid spewing preference updates when state is updated multiple times within a short time period.
        //    saveState: Ext.Function.createBuffered(function () {
        //        if (!this.isDestroyed) {
        //            Ext.state.Stateful.prototype.saveState.apply(this, arguments);
        //        }
        //    }, 100),
        //
        //    /**
        //     * Reconfigure the columns to be displayed in the grid.
        //     * @param {Boolean} true to override existing column config with new column config already exists
        //     * @param {Boolean} true to suspend store load if it will be triggered elsewhere
        //     */
        //    reconfigureWithColumns: function(columnCfgs, reconfigureExistingColumns, suspendLoad) {
        //        columnCfgs = this._getStatefulColumns(columnCfgs);
        //        console.log('reconfigurewithcolumns', columnCfgs, this.columns);
        //        if (!reconfigureExistingColumns) {
        //            columnCfgs = this._mergeColumnConfigs(columnCfgs, this.columns);
        //        }
        //        console.log('reconfigurewithcolumns2', columnCfgs, this.columns);
        //        this.columnCfgs = columnCfgs;
        //        this._buildColumns(true);
        //        this.getStore().fetch = this._buildFetch();
        //        console.log('reconfigurewithcolumns3', this.columnCfgs, this.columns);
        //
        //        this.on('reconfigure', function() {
        //            this.headerCt.setSortState();
        //        }, this, {single: true});
        //        this.reconfigure(null, this.columns);
        //        this.columns = this.headerCt.items.getRange();
        //
        //        if (!suspendLoad) {
        //            this.getStore().load();
        //        }
        //    },
        //
        //    _getColumnConfigFromColumn: function(column) {
        //        var config = {
        //            xtype: column.xtype,
        //            dataIndex: column.dataIndex,
        //            text: column.text,
        //            sortable: column.sortable,
        //            width: Ext.isFunction(column.getWidth) ? column.getWidth() : column.width
        //        };
        //
        //        this._setColumnFlex(config);
        //
        //        return config;
        //    },
        //
        //    _setColumnFlex: function(column) {
        //        if (column.width) {
        //            column.flex = column.width;
        //            delete column.width;
        //        } else if (!_.isNumber(column.flex)) {
        //            column.flex = Rally.ui.grid.FieldColumnFactory.defaultFlexValue;
        //        }
        //    },
        //
        //    _getDataIndex: function(column) {
        //        return column.dataIndex ? column.dataIndex : column;
        //    },
        //
        //    _mergeColumnConfigs: function(newColumns, oldColumns) {
        //        var new_columns =  _.map(newColumns, function(newColumn) {
        //            var oldColumn = _.find(oldColumns, {dataIndex: this._getDataIndex(newColumn)});
        //            if (oldColumn) {
        //                return this._getColumnConfigFromColumn(oldColumn);
        //            }
        //            return newColumn;
        //        }, this);
        //
        //        _.each(oldColumns, function(o){
        //            if (o.xtype === 'costtemplatecolumn'){
        //                new_columns.push(o);
        //            }
        //        });
        //
        //
        //        return new_columns;
        //    },
        //
        //    _getExpandColumnCfg: function() {
        //        var xtype = this.expandAllInColumnHeaderEnabled ? 'rallyformattedidtreecolumn' : 'treecolumn';
        //
        //        return {
        //            xtype: xtype,
        //            text: this.treeColumnHeader,
        //            dataIndex: this.treeColumnDataIndex,
        //            draggable: false,
        //            resizable: this.treeColumnResizable,
        //            renderer: this.treeColumnRenderer,
        //            scope: this,
        //            menuDisabled: this.disableColumnMenus,
        //            listeners: {
        //                beforerender: function(column) {
        //                    if (!column.initialConfig.renderer) {
        //                        column.origRenderer = Rally.ui.grid.CellRendererFactory.createRendererFunction(column);
        //                    }
        //                }
        //            }
        //        };
        //    },
        //
        //    _buildColumns: function(isReconfiguring) {
        //        var model = this.getStore().model;
        //        var disabledEditorColumns = ['DisplayColor'].concat(this.enableBlockedReasonPopover ? ['Blocked'] : []);
        //        var columnCfgs = Ext.clone(this._getColumnCfgs());
        //        console.log('____buildColumns', columnCfgs);
        //        if (!this.enableRanking) {
        //            this.rowActionColumnConfig = _.merge({
        //                menuOptions: {
        //                    showRankMenuItems: false
        //                }
        //            }, this.rowActionColumnConfig);
        //        }
        //
        //        var rowActionOptions = this.shouldShowRowActionsColumn && this.rowActionColumnConfig ? this.rowActionColumnConfig : this.shouldShowRowActionsColumn;
        //
        //        if (this.store.enableHierarchy) {
        //            columnCfgs.unshift(this._getExpandColumnCfg());
        //        }
        //        this.columns = Ext.create('Rally.ui.grid.ColumnBuilder').
        //            withDefaultColumns(columnCfgs).
        //            withSortableColumns(this.sortableColumns).
        //            shouldAutoAddAllModelFieldsAsColumns(this.autoAddAllModelFieldsAsColumns).
        //            withDisableColumnMenus(this.disableColumnMenus).
        //            withEditorsDisabledForColumns(disabledEditorColumns).
        //            withEditingEnabled(this.enableEditing).
        //            withRankingEnabled(this.enableRanking).
        //            withTreeEnabled(true).
        //            withSummaryColumns(this.summaryColumns).
        //            withRankColumn(this.enableRanking ? this.rankColumnDataIndex : false).
        //            shouldShowRowActionsColumn(rowActionOptions).
        //            shouldResetFlexValuesToDefaults(isReconfiguring).
        //            buildCmps(model);
        //
        //        console.log('___buildColumns', this.columns);
        //    },
        //
        //    getAllFetchFields: function() {
        //        return this.getStore().fetch;
        //    },
        //
        //    _buildFetch: function() {
        //        var fetchConfig = this.getStore().fetch || [];
        //
        //        if (fetchConfig === true) {
        //            return fetchConfig;
        //        }
        //
        //        var fetchFields = Ext.create('Rally.ui.grid.data.ColumnFetchBuilder').build({
        //            grid: this,
        //            columns: this.columns,
        //            fetch: fetchConfig
        //        });
        //
        //        return _.union(fetchFields, [this.treeColumnDataIndex]);
        //    },
        //
        //    /**
        //     * Highlights the row representing the passed in record.
        //     * @param record
        //     */
        //    highlightRowForRecord: function(records) {
        //        var store = this.getStore(),
        //            recordIds = _.uniq(_.map(Ext.Array.from(records), function(record) {
        //                return record.getId();
        //            }));
        //
        //        _.each(recordIds, function(recordId) {
        //            var relatedRecords = store.findAllRecordsWithId(recordId);
        //
        //            _.each(relatedRecords, function(relatedRecord) {
        //                var row = this.getView().getNode(relatedRecord);
        //                if (row) {
        //                    Rally.util.Animation.highlight(Ext.fly(row).select('td'));
        //                }
        //            }, this);
        //        }, this);
        //    },
        //
        //    getItemSelector: function() {
        //        return this.view.getItemSelector();
        //    },
        //
        //    getRecord: function(x) {
        //        return this.view.getRecord(x);
        //    },
        //
        //    /**
        //     * Get models used by this grid
        //     *
        //     * @return {Model[]} models
        //     */
        //    getModels: function() {
        //        return [this.store.model];
        //    },
        //
        //    _setupPlugins: function(config) {
        //        var plugins = config.plugins || [];
        //
        //        plugins.push({ptype: 'rallytreegridobjectupdatelistener'});
        //        plugins.push({ptype: 'rallycolorpickerplugin'});
        //
        //        if (this.enableEditing) {
        //            plugins.push(Ext.apply({
        //                ptype: 'rallycellediting',
        //                messageBus: this._getMessageBus()
        //            }, this.editingConfig));
        //
        //            if (this.enableValidationUi) {
        //                plugins.push({ptype: 'rallygridvalidation'});
        //                plugins.push({ptype: 'rallycellvalidationui'});
        //            }
        //        }
        //
        //        if (this.enableBlockedReasonPopover) {
        //            plugins.push({ptype: 'rallyblockedreasonpopoverplugin'});
        //        }
        //
        //        if (!this.treeColumnResizable) {
        //            plugins.push({ptype: 'rallycolumnautosizerplugin'});
        //        }
        //
        //        if (this.bufferedRenderer) {
        //            plugins.push({
        //                ptype: 'rallybufferedrenderer',
        //                trailingBufferZone: 10, // increasing these values to 15 significantly degrades grid refresh performance
        //                leadingBufferZone: 10,
        //                variableRowHeight: this.variableRowHeight
        //            });
        //        }
        //
        //        if (this.store && this.store.enableHierarchy) {
        //            plugins.push({ptype: 'rallytreegridchildpager'});
        //        }
        //
        //        plugins.push({ptype: 'rallyclickhandlerplugin'});
        //
        //        if(this.enableInlineAdd){
        //            plugins.push(Ext.apply({
        //                ptype: 'rallyinlineaddrowexpander'
        //            }, this.inlineAddConfig));
        //        }
        //
        //        if (Rally.realtime.Realtime.enabled) {
        //            plugins.push({ptype: 'rallyrealtime'});
        //        }
        //
        //        plugins.push('rallyboardformattedidhoverable');
        //
        //        return _.uniq(plugins, 'ptype');
        //    },
        //
        //    _setupFeatures: function(config) {
        //        var features = [];
        //        if (this._shouldShowSummary()) {
        //            features.push({
        //                ftype: 'summaryrow',
        //                id: 'summaryrow'
        //            });
        //        }
        //
        //        return features;
        //    },
        //
        //    _shouldShowSummary: function() {
        //        return !(_.isEmpty(this.summaryColumns));
        //    },
        //
        //    _resetCurrentPage: function() {
        //        if (this.stateful) {
        //            //  NOTE: Considered extending Ext.state.stateful and adding a method to override a property on the
        //            //  state (which is what this is doing). If you are reading this to see how this was done, it's
        //            //  probably time to go ahead and make that change.
        //            var state = Ext.state.Manager.get(this.getStateId());
        //            if (state && Ext.isObject(state.pagingToolbar)) {
        //                state.pagingToolbar.currentPage = 1;
        //                Ext.state.Manager.set(this.getStateId(), state);
        //            }
        //        }
        //    },
        //
        //    _onStoreLoad: function() {
        //        this._showNoData();
        //        this._toggleHierarchy();
        //    },
        //
        //    _onDataChanged: function() {
        //        this._showNoData();
        //    },
        //
        //    _onExcludeByFilter: function(excludedRecord) {
        //        if (_.isFunction(this.showNewItemExcludedByFiltersWarning)) {
        //            this.showNewItemExcludedByFiltersWarning(excludedRecord);
        //        }
        //    },
        //
        //    _onMoveToPage: function(record, pageNumber) {
        //        if (_.isFunction(this.showItemMovedToPageNotification)) {
        //            var me = this;
        //            this.showItemMovedToPageNotification(record, pageNumber, function() {
        //                me.getStore().loadPage(pageNumber);
        //            });
        //        }
        //    },
        //
        //    _showNoData: function() {
        //        if (!this.store.getRootNode().hasChildNodes()) {
        //            this.getView().showNoData({
        //                noDataHelpLink: this.noDataHelpLink,
        //                itemName: this.noDataItemName,
        //                filters: [],
        //                useFilterCollection: false
        //            });
        //        }
        //    },
        //
        //    _toggleHierarchy: function() {
        //        if (this.getStore().isHierarchyEnabled()) {
        //            this.addCls('enable-hierarchy');
        //            this.removeCls('disable-hierarchy');
        //        } else {
        //            this.removeCls('enable-hierarchy');
        //            this.addCls('disable-hierarchy');
        //        }
        //    },
        //
        //    _buildDockedItems: function() {
        //        this.dockedItems = this.dockedItems || [];
        //        this.dockedItems.push(Ext.apply({
        //            itemId: 'pagingToolbar',
        //            xtype: 'rallytreepagingtoolbar',
        //            dock: 'bottom',
        //            store: this.store
        //        }, this.pagingToolbarCfg));
        //    }
        //});
        //

                
Ext.define('TreeGridContainerCustomFilterControl', {
    alias: 'plugin.treegridcontainercustomfiltercontrol',
    extend:'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',

    showControl: function() {
        if (!this.controlCmp) {
            this._createControlCmp();
        }

        if (this.controlCmp) {
            this.controlCmp.show();
        }

        return this.controlCmp;
    }
});

                    Ext.define('TreeGridContainerFieldPicker', {
        alias: 'plugin.treegridcontainerfieldpicker',
        extend:'Ext.AbstractPlugin',
        mixins: ['Rally.ui.gridboard.plugin.GridBoardControlShowable'],
        requires: [
            'Rally.ui.popover.Popover',
            'Rally.ui.Button',
            'Rally.ui.picker.FieldPicker'
        ],

        /**
         * @cfg {String[]} alwaysSelectedFields
         * The fields that will be always selected in the field picker for the grid view
         */
        gridAlwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

        /**
         * @cfg {String[]} gridFieldBlackList
         * The fields that will be blacklisted in grid mode
         */
        gridFieldBlackList: [
            'Actuals',
            'Changesets',
            'Children',
            'Description',
            'Notes',
            'ObjectID',
            'Predecessors',
            'RevisionHistory',
            'Subscription',
            'Successors',
            'TaskIndex',
            'Workspace',
            'VersionId'
        ],

        /**
         * @cfg {String[]}
         * the names of the models displayed on the board.
         */
        modelNames: [],

        stateful: true,

        margin: '3 9 10 10',

        constructor: function (config) {
            config.gridFieldBlackList = _.union(this.gridFieldBlackList, config.gridFieldBlackList);
            config.gridAlwaysSelectedValues = _.union(this.gridAlwaysSelectedValues, config.gridAlwaysSelectedValues);
            this.callParent(arguments);
        },

        init: function(cmp) {
            this.callParent(arguments);
            this.cmp = cmp;

            var rankingEnabled = this.cmp.getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled && cmp.gridConfig.enableRanking !== false;

            this.gridAlwaysSelectedValues = this._modifyFieldCollection(this.gridAlwaysSelectedValues, ['DragAndDropRank'], rankingEnabled);
            this.gridFieldBlackList = this._modifyFieldCollection(this.gridFieldBlackList, ['DragAndDropRank'], !rankingEnabled);
            this.stateId = this.stateId || this.cmp.getContext().getScopedStateId('shownfields');

            var state = Ext.state.Manager.get(this.stateId);
            this._fields = state && state.fields;

            this.showControl();
        },
        showControl: function() {
            if (!this.controlCmp) {
                this._createControlCmp();
            }

            if (this.controlCmp) {
                this.controlCmp.show();
            }

            return this.controlCmp;
        },
        _modifyFieldCollection: function (collection, fields, include) {
            if (include) {
                return _.union(collection, fields);
            }
            return _.reject(collection, function (field) { return _.contains(fields, field); });
        },

        getControlCmpConfig: function() {
            return {
                xtype: "rallybutton",
                itemId: 'fieldpickerbtn',
                cls: 'field-picker-btn secondary rly-small',
                margin: this.margin,
                iconCls: 'icon-add-column',
                toolTipConfig: {
                    html: this.getTitle(),
                    anchor: 'top'
                },
                listeners: {
                    click: this._onClick,
                    scope: this
                }
            };
        },

        _onClick: function(btn) {
            this._createPopover(btn.getEl());
        },

        _getPickerConfig: function() {
            var pickerConfig;

            pickerConfig = _.extend({
                value: _.pluck(this.cmp.getGrid().columns, 'dataIndex').join(','),
                fieldBlackList: this.gridFieldBlackList,
                alwaysSelectedValues: this.gridAlwaysSelectedValues
            }, this.fieldPickerConfig);

            return pickerConfig;
        },

        _createPopover: function(popoverTarget) {
            this.popover = Ext.create('Rally.ui.popover.Popover', {
                target: popoverTarget,
                placement: ['bottom', 'left', 'top', 'right'],
                cls: 'field-picker-popover',
                toFront: Ext.emptyFn,
                buttonAlign: 'center',
                title: this.getTitle(),
                listeners: {
                    destroy: function () {
                        this.popover = null;
                    },
                    scope: this
                },
                buttons: [
                    {
                        xtype: "rallybutton",
                        text: 'Apply',
                        cls: 'field-picker-apply-btn primary rly-small',
                        listeners: {
                            click: function() {
                                this._onApply(this.popover);
                            },
                            scope: this
                        }
                    },
                    {
                        xtype: "rallybutton",
                        text: 'Cancel',
                        cls: 'field-picker-cancel-btn secondary dark rly-small',
                        listeners: {
                            click: function() {
                                this.popover.close();
                            },
                            scope: this
                        }
                    }
                ],
                items: [
                    _.extend({
                        xtype: 'rallyfieldpicker',
                        cls: 'field-picker',
                        itemId: 'fieldpicker',
                        modelTypes: this._getModelTypes(),
                        alwaysExpanded: true,
                        width: 200,
                        placeholderText: 'Search',
                        selectedTextLabel: 'Selected',
                        availableTextLabel: 'Available',
                        listeners: {
                            specialkey: function(field, e) {
                                if (e.getKey() === e.ESC) {
                                    this.popover.close();
                                }
                            },
                            scope: this
                        }
                    }, this._getPickerConfig())
                ]
            });
        },

        _getModelTypes: function() {
            return _.pluck(this._getModels(), 'typePath');
        },

        _getModels: function() {
            return _.reduce(this.cmp.getModels(), function(accum, model) {
                if (model.typePath === 'artifact') {
                    accum = accum.concat(model.getArtifactComponentModels());
                } else {
                    accum.push(model);
                }
                return accum;
            }, []);
        },


        getTitle: function () {
            return 'Show Columns';
        },

        /**
         * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
         * the fields on the cards
         *
         * @param {String[]|Object[]} fields A list of field names to display
         * @param {Boolean} true to suspend store load if it will be triggered elsewhere
         */
        updateFields: function (fields, suspendLoad) {
            this._fields = fields;

            console.log('updateFields', fields);

            this.cmp.updateFields(fields);

            this._updatePickerValue(fields);
        },

        _updatePickerValue: function(fields) {
            if (this.popover && this.popover.down('rallyfieldpicker')) {
                this.popover.down('rallyfieldpicker').setValue(this._fields.join(','));
            }
        },

        _onApply: function(popover) {
            var fieldPicker = popover.down('rallyfieldpicker'),
                fields = _.map(fieldPicker.getValue(), function (field) {
                    return field.get('name');
                });

            this.updateFields(fields);

            popover.close();
        }
    });

                Ext.define('TreeGridContainer', {
    extend: 'Ext.Container',
    mixins: ['Rally.app.Scopeable'],
    requires: [
        'Rally.ui.LeftRight',
        'Rally.ui.grid.TreeGrid'
    ],

    alias: 'widget.treegridcontainer',
    cls: 'rui-gridboard',
    /**
     * @cfg {Object}
     * Common store configuration properties
     * to be applied to both the board and grid views
     */
    storeConfig: {},
    gridConfig: {},
    /**
     * @cfg {Array}
     * An array of model names of types to view on the grid board.
     */
    modelNames: [],
    /**
     * @inheritdoc
     */
    layout: {
        type: 'auto'
    },

    currentCustomFilter: [],

    items: [
        {
            itemId: 'header',
            xtype: 'rallyleftright',
            padding: '4 10 10 10',
            overflowX: 'hidden'
        }
    ],
    initComponent: function () {
        this.plugins = this.plugins || [];
        this.stateId = this.getAppContextOrEnvironmentContext().getScopedStateId(this.stateId);

        this.callParent(arguments);

        this.addEvents([
        /**
         * @event load
         * Fires when the data store for the grid or board has loaded.
         * @param {Rally.ui.gridboard.GridBoard} this
         */
            'load',
        /**
         * @event recordcreate
         * Fires when a new record is created.
         * @param {Ext.data.Record} record The record that was created.
         */
            'recordcreate',
        /**
         * @event recordupdate
         * Fires when a record is updated.
         */
            'recordupdate',
        /**
         * @event preferencesaved
         * Fires after the preference has been saved
         * @param {Rally.data.wsapi.Model} record for preference
         */
            'preferencesaved',
        /**
         * @event modeltypeschange
         * Fires when the model types of the gridboard are changed.
         */
            'modeltypeschange'
        ]);

        this.on('modeltypeschange', function (gridboard, types) {
            this.modelNames = types;
        }, this);
    },
    /**
     * Delay the addition of the grid or board until plugins had a chance to modify some state
     * and the header has rendered in order to set the height of the tree grid.
     * Plugins can modify things like what fields are displayed
     * @private
     */
    afterRender: function () {
        this.callParent(arguments);
        this._addGrid();
    },
    destroy: function () {
        var grid = this.getGrid();

        if (grid && grid.store && _.isFunction(grid.store.clearData)) {
            //clean up records in the store to free up memory
            grid.store.clearData();
        }

        this.callParent(arguments);
    },
    getGrid: function () {
        return this.down('rallytreegrid');
    },
    /**
     * Get the header
     * @return {Rally.ui.LeftRight}
     */
    getHeader: function () {
        return this.down('#header');
    },
    /**
     * Get the names of the artifacts currently shown
     * @returns {String[]}
     */
    getModelNames: function () {
        return this.modelNames;
    },
    /**
     * Get the models of the artifacts currently shown
     * @returns {Rally.data.Model[]}
     */
    getModels: function () {
        return this.getGrid().getModels();
    },
    applyCustomFilter: function (filterObj) {
        var grid = this.getGrid();

        this.currentCustomFilter = filterObj;
        console.log('grid', grid);
        if (grid) {
            this._applyGridFilters(grid, filterObj);
        }
    },
    /**
     * Returns the currently applied filter.
     *
     * @returns {Ext.util.Filter|Ext.util.Filter[]|Object|Object[]}
     */
    getFilter: function () {
        return this.currentFilter;
    },

    setHeight: function () {
        this.callParent(arguments);
        var grid = this.getGrid();
        if (grid && grid.rendered && grid.getHeight() !== this.getAvailableGridBoardHeight()) {
            this.grid().setHeight(this.getAvailableGridBoardHeight());
        }
    },
    /**
     * @private
     */
    getAvailableGridBoardHeight: function () {
        return this.getHeight() - this.down('#header').getHeight() - 10;
    },
    /**
     * This function is called from the FieldPicker plugin to update the displayed fields
     * In the Gridboard, this calls the reconfigureWithColumns function on the TreeGrid
     * @param fields
     */
    updateFields: function(fields){
        console.log('updateFields', fields);
        var grid = this.getGrid();

        columnCfgs = grid._getStatefulColumns(fields);

        //Always use the old configuration if we have it.
        fieldscolumnCfgs = grid._mergeColumnConfigs(columnCfgs, this.columns);

        columnCfgs = Ext.Array.merge(columnCfgs, this.gridConfig.customColumns || []);

        console.log('columnCfgs', columnCfgs);

        grid.columnCfgs = columnCfgs;

       // grid.getStore().load();

        //this._buildColumns(true);  //sets grid.columns
        //this.getStore().fetch = this._buildFetch();
        //
        //this.on('reconfigure', function() {
        //    this.headerCt.setSortState();
        //}, this, {single: true});
        //this.reconfigure(null, this.columns);
        //this.columns = this.headerCt.items.getRange();
        //
        //if (!suspendLoad) {
        //    this.getStore().load();
        //}

    },
    _getGridConfig: function () {
        var context = this.getContext() || Rally.environment.getContext(),
            columnCfgs = Ext.Array.merge(this.gridConfig.columnCfgs || [], this.gridConfig.customColumns || []),
            config = Ext.merge({
                xtype: 'rallytreegrid',
                context: context,
                enableRanking: false, //context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled,
                defaultSortToRank: true,
                enableBlockedReasonPopover: true,
                //stateId: this.stateId + '-grid',
                //stateful: true,
                height: this.getAvailableGridBoardHeight()
            }, this.gridConfig);

            config.columnCfgs = columnCfgs;

        if (_.isEmpty(config.store)) {
            Ext.Error.raise('No grid store configured');
        }
        return config;
    },
    _getConfiguredFilters: function (extraFilters, types) {
        var filters = _.compact(Ext.Array.merge(
            this.getGrid().store.filters,
            this.storeConfig && this.storeConfig.filters,
            this.gridConfig && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
            extraFilters));


        console.log('_getConfiguredFilters',filters.toString(),
            _.isFunction(this.getModels()[0].getArtifactComponentModel));

        // don't do this if not artifact model or we are using filter collection
        //if ( _.isFunction(this.getModels()[0].getArtifactComponentModel)) {
        //    filters = Rally.util.Filter.removeNonapplicableTypeSpecificFilters(filters, types, this.getModels()[0]);
        //}
        console.log('_getConfiguredFilters', filters.toString);
        return filters;
    },

    _addGrid: function () {
        var grid = this.add(this._getGridConfig());
        this.mon(grid, 'afterproxyload', this._onGridLoad, this);
        if (this.currentCustomFilter) {
            this._applyGridFilters(grid, this.currentCustomFilter);
        }
       return grid;
    },
    _applyGridFilters: function (grid, filterObj) {
        if (!_.isEmpty(filterObj.types)) {
            grid.store.parentTypes = filterObj.types;
        }
        grid.store.clearFilter(true);
        console.log('applied filters', this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
        grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
    },
    _onGridLoad: function () {
        this.fireEvent('load', this);

        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    }

});
                Ext.define('HierarchyExporter',{

    parentModel: null,
    descendantModels: null,
    fetch: null,
    filters: null,

    constructor: function(config) {
        Ext.merge(this,config);
    },
    /**
     * fetchResults: returns an array of arrays that can be manipulated into a delimited string or some other data structure
     * for exporting/manipulation
     **/
    fetchResults: function(){
        var deferred = Ext.create('Deft.Deferred');

        PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords(this.parentModel, this.filters,this.fetch).then({
            success: function(records){
                deferred.resolve(records);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });


        return deferred;
    },

    //exportDetail: function(filename, grid){
    //    var root = grid.store.getRootNode();
    //    var columnsOfInterest = _.map(grid.columnCfgs, function(cfg){
    //        if (typeof cfg == 'object'){
    //            return cfg.dataIndex;
    //        }
    //        return cfg;
    //    });
    //    columnsOfInterest = _.without(columnsOfInterest,'FormattedID');
    //
    //    //We want the first child of the root node, plus its' children
    //    this._exportNodeDetail(root,columnsOfInterest, filename);
    //
    //},
    //_exportNodeDetail: function(expandedNode,columnsOfInterest,filename){
    //    var nodeDepth = Rally.technicalservices.Export._getDeepestNodeDepth(expandedNode);
    //    var nameIndex = nodeDepth;
    //
    //    var headers = [];
    //    for (var i=0; i<nodeDepth; i++){
    //        headers.push('');
    //    }
    //    headers[0] = 'Initiative';
    //    headers[1] = 'Feature';
    //    headers.push(columnsOfInterest);
    //    headers = _.flatten(headers);
    //    var rows = Rally.technicalservices.util.Excel.formatArrayAsRow(headers);
    //
    //
    //    Ext.each(expandedNode.childNodes, function (firstLevelNode) {
    //        var arr = Rally.technicalservices.Export._initializeArray(firstLevelNode.getDepth(), nameIndex, firstLevelNode.data.FormattedID);
    //        Ext.each(columnsOfInterest, function(col){
    //            arr.push(firstLevelNode.data[col]);
    //        });
    //        rows += Rally.technicalservices.util.Excel.formatArrayAsRow(_.flatten(arr));
    //        rows += Rally.technicalservices.Export._getChildNodeRows(true, firstLevelNode, nameIndex, columnsOfInterest);
    //    });
    //    var table = Rally.technicalservices.util.Excel.formatTable(rows);
    //    var text = Rally.technicalservices.util.Excel.formatHtml(Rally.technicalservices.util.Excel.formatBody(table));
    //    Rally.technicalservices.FileUtilities.saveTextAsFile(text,filename);
    //},
    //
    //_getChildNodeRows: function(recursive, parentNode, columnIndex, columnsOfInterest){
    //    var depth = parentNode.getDepth();
    //    var text = '';
    //    Ext.each(parentNode.childNodes, function(childNode){
    //        var arr = Rally.technicalservices.Export._initializeArray(childNode.getDepth(), columnIndex, childNode.data.FormattedID);
    //        arr.push(_.values(_.pick(childNode.data, columnsOfInterest)));
    //        text += Rally.technicalservices.util.Excel.formatArrayAsRow(_.flatten(arr));
    //        if (recursive){
    //            text += Rally.technicalservices.Export._getChildNodeRows(true, childNode, columnIndex, columnsOfInterest);
    //        }
    //    });
    //    return text;
    //},
    //_getNodeDepth: function(node){
    //    var depth =  node.getDepth();
    //
    //    if (node.hasChildNodes()){
    //        node.eachChild(function(child){
    //            var childDepth = Rally.technicalservices.Export._getNodeDepth(child);
    //            if (childDepth > depth){
    //                depth = childDepth;
    //            }
    //        });
    //    }
    //
    //    return depth;
    //},
    //
    //exportSummary: function(filename, grid){
    //    var root = grid.store.getRootNode();
    //    var columnsOfInterest = _.map(grid.columnCfgs, function(cfg){
    //        if (typeof cfg == 'object'){
    //            return cfg.dataIndex;
    //        }
    //        return cfg;
    //    });
    //    columnsOfInterest = _.without(columnsOfInterest,'FormattedID');
    //
    //    //We want the first child of the root node, plus its' children
    //    this._exportNodeSummary(root,columnsOfInterest, filename);
    //
    //},
    //_exportNodeSummary: function(expandedNode,columnsOfInterest,filename){
    //    var headers = [];
    //    headers[0] = 'Initiative';
    //    headers[1] = 'Feature';
    //    headers.push(columnsOfInterest);
    //    headers = _.flatten(headers);
    //    var rows = Rally.technicalservices.util.Excel.formatArrayAsRow(headers);
    //
    //    Ext.each(expandedNode.childNodes, function (firstLevelNode) {
    //        var arr = Rally.technicalservices.Export._initializeArray(firstLevelNode.getDepth(), 2, firstLevelNode.data.FormattedID);
    //        Ext.each(columnsOfInterest, function(col){
    //            arr.push(firstLevelNode.data[col]);
    //        });
    //        rows += Rally.technicalservices.util.Excel.formatArrayAsRow(_.flatten(arr));
    //        rows += Rally.technicalservices.Export._getChildNodeRows(false, firstLevelNode, 2, columnsOfInterest);
    //    });
    //    var table = Rally.technicalservices.util.Excel.formatTable(rows);
    //    var text = Rally.technicalservices.util.Excel.formatHtml(Rally.technicalservices.util.Excel.formatBody(table));
    //    Rally.technicalservices.FileUtilities.saveTextAsFile(text,filename);
    //},
    //
    //_initializeArray: function(nodeDepth, columnIndex, formattedID){
    //    var arr = _.range(columnIndex).map(function(a){return ''});
    //    arr[nodeDepth-1] = formattedID;
    //    return arr;
    //},
    //_getDeepestNodeDepth: function(root){
    //    var depth = 0;
    //    root.eachChild(function(node){
    //        var nodeDepth = Rally.technicalservices.Export._getNodeDepth(node);
    //        if (nodeDepth > depth){
    //            depth = nodeDepth;
    //        }
    //    });
    //    return depth;
    //},
    //
    //
    //convertDataArrayToCSVText: function(data_array, requestedFieldHash){
    //
    //    var text = '';
    //    Ext.each(Object.keys(requestedFieldHash), function(key){
    //        text += requestedFieldHash[key] + ',';
    //    });
    //    text = text.replace(/,$/,'\n');
    //
    //    Ext.each(data_array, function(d){
    //        Ext.each(Object.keys(requestedFieldHash), function(key){
    //            if (d[key]){
    //                if (typeof d[key] === 'object'){
    //                    if (d[key].FormattedID) {
    //                        text += Ext.String.format("\"{0}\",",d[key].FormattedID );
    //                    } else if (d[key].Name) {
    //                        text += Ext.String.format("\"{0}\",",d[key].Name );
    //                    } else if (!isNaN(Date.parse(d[key]))){
    //                        text += Ext.String.format("\"{0}\",",Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
    //                    }else {
    //                        text += Ext.String.format("\"{0}\",",d[key].toString());
    //                    }
    //                } else {
    //                    text += Ext.String.format("\"{0}\",",d[key] );
    //                }
    //            } else {
    //                text += ',';
    //            }
    //        },this);
    //        text = text.replace(/,$/,'\n');
    //    },this);
    //    return text;
    //},
    ///*
    // * will render using your grid renderer.  If you want it to ignore the grid renderer,
    // * have the column set _csvIgnoreRender: true
    // */
    //getCSVFromTreeGrid:function(app, grid){
    //    var deferred = Ext.create('Deft.Deferred');
    //
    //    var store = Ext.create('Rally.data.wsapi.Store',{
    //        fetch: grid.getStore().config.fetch,
    //        filters: grid.getStore().config.filters,
    //        model: grid.getStore().config.model,
    //        pageSize: 200
    //    });
    //
    //    var columns = grid.columns;
    //    var column_names = [];
    //    var headers = [];
    //
    //    Ext.Array.each(columns,function(column){
    //        if ( column.dataIndex || column.renderer ) {
    //            column_names.push(column.dataIndex);
    //            if ( column.csvText ) {
    //                headers.push(column.csvText);
    //            } else {
    //                headers.push(column.text);
    //            }
    //        }
    //    });
    //
    //    var record_count = grid.getStore().getTotalCount(),
    //        page_size = grid.getStore().pageSize,
    //        pages = Math.ceil(record_count/page_size),
    //        promises = [];
    //
    //    for (var page = 1; page <= pages; page ++ ) {
    //        promises.push(this.loadStorePage(app, grid, store, columns, page, pages));
    //    }
    //    Deft.Promise.all(promises).then({
    //        success: function(csvs){
    //            var csv = [];
    //            csv.push('"' + headers.join('","') + '"');
    //            _.each(csvs, function(c){
    //                _.each(c, function(line){
    //                    csv.push(line);
    //                });
    //            });
    //            csv = csv.join('\r\n');
    //            deferred.resolve(csv);
    //            app.setLoading(false);
    //        }
    //    });
    //    return deferred.promise;
    //
    //},
    //loadStorePage: function(app, grid, store, columns, page, total_pages){
    //    var deferred = Ext.create('Deft.Deferred');
    //    this.logger.log('loadStorePage',page, total_pages);
    //
    //    var mock_meta_data = {
    //        align: "right",
    //        classes: [],
    //        cellIndex: 9,
    //        column: null,
    //        columnIndex: 9,
    //        innerCls: undefined,
    //        recordIndex: 5,
    //        rowIndex: 5,
    //        style: "",
    //        tdAttr: "",
    //        tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
    //        unselectableAttr: "unselectable='on'"
    //    }
    //
    //    store.loadPage(page, {
    //        callback: function (records) {
    //            var csv = [];
    //            app.setLoading(Ext.String.format('Page {0} of {1} loaded',page, total_pages));
    //            for (var i = 0; i < records.length; i++) {
    //                var record = records[i];
    //
    //                var node_values = [];
    //                Ext.Array.each(columns, function (column) {
    //                    if (column.xtype != 'rallyrowactioncolumn') {
    //                        if (column.dataIndex) {
    //                            var column_name = column.dataIndex;
    //                            var display_value = record.get(column_name);
    //
    //                            if (!column._csvIgnoreRender && column.renderer) {
    //                                if (column.exportRenderer) {
    //                                    display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
    //                                } else {
    //                                    display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
    //                                }
    //                            }
    //                            node_values.push(display_value);
    //                        } else {
    //                            var display_value = null;
    //                            if (!column._csvIgnoreRender && column.renderer) {
    //                                if (column.exportRenderer) {
    //                                    display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
    //                                } else {
    //                                    display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
    //                                }
    //                                node_values.push(display_value);
    //                            }
    //                        }
    //
    //                    }
    //                }, this);
    //                csv.push('"' + node_values.join('","') + '"');
    //            }
    //            deferred.resolve(csv);
    //        },
    //        scope: this
    //    });
    //    return deferred;
    //}
});


            Rally.launchApp('PortfolioItemCostTracking', {
                name:"portfolio-item-cost-tracking",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
.lbl {
  text-transform: uppercase;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 10px;
}
.x-form-trigger-wrap {
  margin-top: 0px!important;
}

    </style>
</head>
<body>
</body>
</html>
