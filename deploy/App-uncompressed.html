<!DOCTYPE html>
<html>
<head>
    <title>portfolio-item-cost-tracking</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('PortfolioItemCostTracking', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    defaults: {
        startDate: new Date('2015-06-01'),
        endDate: new Date('2016-05-31'),
        groupByRelease: false
    },

    config: {
        defaultSettings: {
            selectedCalculationType: 'points',
            normalizedCostPerUnit: 1000,
            projectCostPerUnit: {},
            currencySign: '$',
            preliminaryBudgetField: 'PreliminaryEstimate'
        }
    },

    items: [],

    portfolioItemRollupData: {},

    launch: function() {

        //ToDO: check for RPM?

        this._createPickers();

        PortfolioItemCostTracking.WsapiToolbox.fetchDoneStates().then({
            success: function(doneScheduleStates){
                PortfolioItemCostTracking.Settings.completedScheduleStates = doneScheduleStates;
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: msg});
            },
            scope: this
        });
    },
    _createPickers: function(piType){

        //var startDate = this.getStartDate(),
        //    endDate = this.getEndDate();
        this.fixedHeader = this.add({ //Ext.create('Ext.container.Container',{
            xtype: 'container',
            itemId: 'header-controls',
            width: 600,
            height: 50,
            layout: {type:  'hbox'},
            padding: '0 0 20 20',
            margin: 10,
            items: [{
                xtype: 'rallyportfolioitemtypecombobox',
                itemId: 'cb-type',
                stateful: true,
                stateId: this.getContext().getScopedStateId('cb-type'),
                stateEvents: ['change'],
                margin: '0 10 0 0',
                fieldLabel: 'Portfolio Item Type',
                labelAlign: 'top',
                labelCls: 'lbl',
                listeners: {
                    scope: this,
                    ready: this._initialize
                }
            }]
        });
    },
    _initialize: function(){
        if (this.fixedHeader && this.fixedHeader.down('#cb-type')){
          //  this.fixedHeader.down('#dt-start') && this.fixedHeader.down('#dt-end')){

            //Get the portfolio item types from the combobox since we have just loaded that.
            var portfolioItemTypes = this._initializePortfolioItemTypes(this.fixedHeader.down('#cb-type'));
            this._initializeSettings(this.getSettings(),null, portfolioItemTypes);

            var state = Ext.state.Manager.get(this.getContext().getScopedStateId('cb-type')),
                state_val = state ? state.value : null;
            if (state_val){
                this.fixedHeader.down('#cb-type').setValue(state_val);
            }

            this.fixedHeader.down('#cb-type').on('change', this._onTypeChange, this);
                //this.fixedHeader.down('#dt-start').on('change', this.updateStoreFilters, this);
                //this.fixedHeader.down('#dt-end').on('change', this.updateStoreFilters, this);
                this._onTypeChange(this.fixedHeader.down('#cb-type'));
        }
    },
    _initializePortfolioItemTypes: function(cb){

        var items = cb.getStore().data.items,
            portfolioItemTypes = new Array(items.length);

        Ext.Array.each(items, function(item){
                var idx = Number(item.get('Ordinal'));
                portfolioItemTypes[idx] = { typePath: item.get('TypePath'), name: item.get('Name'), ordinal: idx };
        });
        return  portfolioItemTypes;
    },
    _onTypeChange: function(piPicker){
        var piType = piPicker.getRecord().get('TypePath');
        this.modelNames = [piType];
        this._initializeGrid(this.modelNames);
    },
    _initializeSettings: function(settings, doneScheduleStates, portfolioItemTypes){

        PortfolioItemCostTracking.Settings.notAvailableText = "--";
        PortfolioItemCostTracking.Settings.currencySign = settings.currencySign;
        PortfolioItemCostTracking.Settings.currencyPrecision = 0;
        PortfolioItemCostTracking.Settings.currencyEnd = false;
        if (doneScheduleStates){
            PortfolioItemCostTracking.Settings.completedScheduleStates = doneScheduleStates;
        }
        if (portfolioItemTypes){
            PortfolioItemCostTracking.Settings.portfolioItemTypes = portfolioItemTypes;
        }

        PortfolioItemCostTracking.Settings.normalizedCostPerUnit = settings.normalizedCostPerUnit;

        var project_cpu = settings.projectCostPerUnit || {};
        if (!Ext.isObject(project_cpu)){
            project_cpu = Ext.JSON.decode(project_cpu);
        }
        PortfolioItemCostTracking.Settings.projectCostPerUnit = project_cpu;

        PortfolioItemCostTracking.Settings.preliminaryBudgetField = settings.preliminaryBudgetField;

        PortfolioItemCostTracking.Settings.setCalculationType(settings.selectedCalculationType);
    },
     _initializeGrid: function(modelNames){

         if (this.rollupData){
             this.rollupData = null;
         }
         var me = this;
         this.rollupData = Ext.create('PortfolioItemCostTracking.RollupCalculator', {});

         if (this.down('treegridcontainer')){
             if (this.fixedHeader && this.fixedHeader.rendered) {
                 var parent = this.fixedHeader.up();
                 if(parent && parent.remove){
                     parent.remove(this.fixedHeader, false);
                 }
             }
             this.down('treegridcontainer').destroy();
        }

        this._updateStore(modelNames);
    },

    addHeader: function (gb) {
        var header = gb.getHeader();

        if (header) {
            header.getLeft().add(this.fixedHeader);
        }
    },
    _getFilters: function(){
        //var filters = this._getDateFilters(),
        var    custom_filters = [];

        if (this.down('treegridcontainer') && this.down('treegridcontainer').currentCustomFilter){
            custom_filters = this.down('treegridcontainer').currentCustomFilter.filters || [];
        }
        return custom_filters;
        //return Ext.Array.merge(filters, custom_filters);

    },
    _showExportMenu: function () {
        var columnCfgs = this.down('treegridcontainer').getGrid().columnCfgs,
            additionalFields = _.pluck(columnCfgs, 'dataIndex');

        var filters = this._getFilters(),
            fetch = PortfolioItemCostTracking.Settings.getTreeFetch(additionalFields),
            root_model = this.modelNames[0];
        console.log('_showExportMenu', fetch,additionalFields);
         var exporter = new PortfolioItemCostTracking.Exporter();
        exporter.fetchExportData(root_model,filters,fetch,columnCfgs).then({
            scope: this,
            success: function(csv){
                var filename = Ext.String.format("export-{0}.csv",Ext.Date.format(new Date(),"Y-m-d-h-i-s"));
                exporter.saveCSVToFile(csv, filename);
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: "An error occurred fetching the data to export:  " + msg});
            }
        });
    },
    updateStoreFilters: function(){

        if (this.down('treegridcontainer')){
            this.down('treegridcontainer').applyCustomFilter(this.down('treegridcontainer').currentCustomFilter);
        }
    },

    _loadRollupData: function(records){

        var loader = Ext.create('PortfolioItemCostTracking.RollupDataLoader',{
            context: this.getContext(),
            rootRecords: records,
            listeners: {
                rollupdataloaded: function(portfolioHash, stories){
                    this._processRollupData(portfolioHash,stories,records);
                },
                loaderror: this._handleLoadError,
                statusupdate: this._showStatus,
                scope: this
            }
        });
        loader.load(records);
    },
    _handleLoadError: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    _processRollupData: function(portfolioHash, stories, records){
        var me = this;
        console.log('rollupdataloaded', portfolioHash, stories.length ,stories, records,records.length);

        portfolioHash[records[0].get('_type').toLowerCase()] = records;
        this.rollupData.addRollupRecords(portfolioHash, stories);
        this.rollupData.updateModels(records);

        me._showStatus(null);
    },
    _showStatus: function(message){
            if (message) {
                Rally.ui.notify.Notifier.showStatus({
                    message: message,
                    showForever: true,
                    closable: false,
                    animateShowHide: false
                });
            } else {
                Rally.ui.notify.Notifier.hide();
            }
    },
    _setRollupData: function(store, node, records, success){

        if (!store.model.getField('_rollupData')){
            store.model.addField({name: '_rollupData', type: 'auto', defaultValue: null});
        }

        var unloadedRecords = this.rollupData.updateModels(records);
        if (unloadedRecords && unloadedRecords.length > 0 && node.parentNode === null){
            this._loadRollupData(unloadedRecords);
        }
        this.down('treegridcontainer').getGrid().getView().refresh();
        //this.down('treegridcontainer').getGrid().refresh()
    },

    _updateStore: function(modelNames){

        var field_names = [];
        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            //filters: filters,
            fetch: PortfolioItemCostTracking.Settings.getTreeFetch(field_names),
            enableHierarchy: true,
            listeners: {
                scope: this,
                load: this._setRollupData
            }
        }).then({
            scope: this,
            success: function(store) {
                 store.model.addField({name: '_rollupData', type: 'auto', defaultValue: null});
                 this._updateDisplay(store, modelNames);
            }
        });
    },
    _updateDisplay: function(store, modelNames){
        var me = this;

        this.add({
            xtype: 'treegridcontainer',
            context: this.getContext(),
            gridConfig: {
                columnCfgs: this._getColumnCfgs(),
                derivedColumns: this._getDerivedColumns(),
                store: store,
              //  stateful: true,
              //  stateId: this.getContext().getScopedStateId('cost-tree-grid')
            },
            plugins:[{
                ptype: 'treegridcontainercustomfiltercontrol',
                filterControlConfig: {
                    modelNames: modelNames,
                    stateful: true,
                    stateId: this.getContext().getScopedStateId('cost-tree-filter'),
                    margin: '15px 10px 0px 0px'
                }
            },{
                ptype: 'treegridcontainerfieldpicker',
                headerPosition: 'left',
                modelNames: modelNames,
               // stateful: true,
              //  stateId: this.getContext().getScopedStateId('cost-tree-field-picker'),
                margin: '15px 0px 10px 10px'
            },{
                ptype: 'rallygridboardactionsmenu',
                menuItems: [
                    {
                        text: 'Export...',
                        handler: me._showExportMenu,
                        scope: me
                    }
                ],
                buttonConfig: {
                    iconCls: 'icon-export',
                    margin: '15px 10px 0px 0px'
                }
            }],
            listeners: {
                beforerender: function(gb){
                    this.addHeader(gb);
                },
                scope: this
            },
            height: this.getHeight()
        });
    },
    _getDerivedColumns: function(){

        return [{
            text: "Actual Cost To Date",
            xtype: 'actualcosttemplatecolumn',
            dataIndex: '_rollupData',
            tooltip: PortfolioItemCostTracking.Settings.getHeaderTooltip('_rollupDataActualCost')
        },{
            text: "Remaining Cost",
            xtype: 'remainingcosttemplatecolumn',
            dataIndex: '_rollupData',
            tooltip: PortfolioItemCostTracking.Settings.getHeaderTooltip('_rollupDataRemainingCost')
        }, {
            text: 'Total Projected',
            xtype: 'totalcosttemplatecolumn',
            dataIndex: '_rollupData',
            tooltip: PortfolioItemCostTracking.Settings.getHeaderTooltip('_rollupDataTotalCost')
        },{
            text: 'Preliminary Budget',
            xtype: 'preliminarybudgettemplatecolumn',
            dataIndex: '_rollupData',
            tooltip: PortfolioItemCostTracking.Settings.getHeaderTooltip('_rollupDataPreliminaryBudget')
        }];
    },
    _getColumnCfgs: function(){

        return  [{
            dataIndex: 'Name',
            text: 'Name',
            flex: 5
        },{
            dataIndex: 'Project',
            text: 'Project',
            editor: false
        },{
            dataIndex: 'LeafStoryPlanEstimateTotal',
            text: 'Plan Estimate Total'
        }, {
            dataIndex: 'PercentDoneByStoryPlanEstimate',
            text: '% Done by Story Points'
        }];
    },
    getSettingsFields: function() {
        return PortfolioItemCostTracking.Settings.getFields(this.getSettings());
    },
    onSettingsUpdate: function(settings){
        this._initializeSettings(settings);
        this._initializeGrid(this.modelNames);
    }
});

                Ext.define('PortfolioItemCostTracking.Settings', {
    singleton: true,

    /**
     * App Settings
     */
    selectedCalculationType: undefined,
    /**
     * Currency display settings to pass into the Ext.util.Format currency function
     */
    currencySign: '$',
    currencyPrecision: 0,
    currencyEnd: false,

    normalizedCostPerUnit: 1,
    projectCostPerUnit: {},

    preliminaryBudgetField: 'PreliminaryEstimate',
    /**
     * App configurations
     */

    tooltipActualCost: 'actualcost ',
    tooltipTotalCost: 'totalcost',
    tooltipRemainingCost: 'remaining cost',
    tooltipPreliminaryBudget: 'preliminary budget',

    calculationTypes: {
        points: {
            key: 'points',
            label: 'Based on Story Points',
            displayName: 'Story Points',
            defaultColumns: ['Name', 'Project', 'PlanEstimate', 'LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','PlanEstimate'],
            requiredTaskFetch: [],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Accepted Story Plan Estimates <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the Total Projected Cost - Actual Cost',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Plan Estimate <i>for each story in scope</i>* Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){
                if (data.PlanEstimate && Ext.Array.contains(PortfolioItemCostTracking.Settings.completedScheduleStates, data.ScheduleState)) {
                    return data.PlanEstimate || 0;
                }
                return 0;
            },
            totalUnitsForStoryFn: function(data){
                return data.PlanEstimate || 0;
            }
        },
        taskHours: {
            key: 'taskHours',
            displayName: 'Task Actuals',
            label: 'Based on Task Actuals',
            defaultColumns: ['Name','Project'],
            requiredStoryFetch: ['ScheduleState','PortfolioItem','TaskEstimateTotal','TaskActualTotal','TaskRemainingTotal'],
            requiredTaskFetch: ['ToDo','Actuals'],
            tooltips: {
                _rollupDataActualCost: 'Actual Cost is the sum of the Task Actuals <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataRemainingCost: 'Remaining Cost is the sum of the ToDo <i>for all stories in scope</i> * Cost Per Unit for the project that the top level story resides in.',
                _rollupDataTotalCost: 'Total Projected Cost is the sum of the Task Estimate Total <i>for each story in scope</i> * Cost Per Unit for the project that the top level story resides in.  <br/><br/> If a Portfolio Item does not have any estimated stories and the Preliminary Budget is greater than the Portfolio Item\'s Actual Cost, then the Preliminary Budget will be used for the Total Projected Cost.',
                _rollupDataPreliminaryBudget: 'The prelimary budget will be calculated by multiplying the value of the selected field by the Cost per Unit for the project of the portfolio item. <br/><br/> Note that for portfolio item types beyond the lowest level, this is calculated from the preliminary estimate of the portfolio item, not from the sum of the portfolio item children.  If the selected field value is null, then -- will be displayed.'
            },
            actualUnitsForStoryFn: function(data){ return data.TaskActualTotal || 0; },
            totalUnitsForStoryFn: function(data){
                return (data.TaskActualTotal || 0) + (data.TaskRemainingTotal || 0);
            },
            actualUnitsForTaskFn: function(data){
                return data.Actuals || 0;
            },
            totalUnitsForTaskFn: function(data){
                return (data.ToDo || 0) + (data.Actuals || 0);
            }
        },
        timesheets: {
            key: 'timesheets',
            displayName: 'Time Spent',
            label: 'Based on Timesheets',
            defaultColumns: ['Name','Project'],
            requiredStoryFetch: [],
            requiredTaskFetch: [],
            disabled: true,
            actualUnitsForStoryFn: function(data){ return 0; },
            actualUnitsForTaskFn: function(data){ return 0; },
            totalUnitsForStoryFn: function(data){  return 0; },
            totalUnitsForTaskFn: function(data){  return 0; }
        }
    },

    /**
     * Required fetch fields in addition to what the Tree might fetch.  We need these for the rollup data fetch lists and for group by Release
     */
    requiredPortfolioItemFetch: ['UserStories'],
    requiredFetch: ['ObjectID','FormattedID','Project','Parent','Children','Release','Name'],

    notAvailableText: '--',

    completedScheduleStates: [],

    portfolioItemTypes: [],

    currencyData: [
        {name: "US Dollars", value: "$"},
        {name: "Euro", value: "&#128;"},
        {name: "Japanese Yen", value: "&#165;"},
        {name: "Brazilian Real", value: "R$"}
    ],
    getHeaderTooltip: function(field){
        var settings = PortfolioItemCostTracking.Settings.getCalculationTypeSettings();
        return settings.tooltips[field] || null;

    },
    setCalculationType: function(type){
         //Check that actuals is on, and warn user if it is not.
        if (type === 'taskHours'){
            Rally.data.ModelFactory.getModel({
                type: 'task',
                success: function(model){
                    var field = model.getField('Actuals');
                    if (field && field.hidden){
                        Rally.ui.notify.Notifier.showWarning({message: 'The Task Actuals field is not visible in the current project.  As a result, Task Actuals values may be 0.'});
                    }
                }
            });
        }


        if (PortfolioItemCostTracking.Settings.calculationTypes[type]){
            PortfolioItemCostTracking.Settings.selectedCalculationType = type;
        } else {
            PortfolioItemCostTracking.Settings.selectedCalculationType = 'points';
        }
    },
    /**
     * getPortfolioItemTypeLevel
     * @param modelName
     * Given a model name, this function returns the level of portfolio item the model name is:
     *  0 = Lowest Level (Feature)
     *  1 = Second Level (e.g. Initiative)
     *  ...
     *  return -1 if the modelName is not a portfolio item type
     */
    getPortfolioItemTypeLevel: function(modelName){
        var idx = _.indexOf(PortfolioItemCostTracking.Settings.getPortfolioItemTypes(), modelName.toLowerCase());
        return idx;
    },
    getRollupItemType: function(type){
        var idx = _.indexOf(PortfolioItemCostTracking.Settings.getPortfolioItemTypes(), type.toLowerCase());
        if (idx > 0){
            return 'PortfolioItemCostTracking.UpperLevelPortfolioRollupItem';
        }
        if (idx === 0){
            return 'PortfolioItemCostTracking.LowestLevelPortfolioRollupItem';
        }
        return null;
    },
    getPortfolioItemTypes: function(){
        return _.map( this.portfolioItemTypes, function(p){ return p.typePath.toLowerCase(); });
    },
    getPortfolioItemTypeObjects: function(){
        return this.portfolioItemTypes;
    },
    getTypePathDisplayName: function(piTypePath){
        if (piTypePath.toLowerCase() === 'hierarchicalrequirement'){
            return 'User Story';
        }

        var piDisplayName = '';

        Ext.Array.each(this.portfolioItemTypes, function(p){
            if (p.typePath.toLowerCase() === piTypePath.toLowerCase()){
                piDisplayName = p.name;
                return false;
            }
        });
        return piDisplayName;
    },
    getCalculationTypeSettings: function(){
        return PortfolioItemCostTracking.Settings.calculationTypes[PortfolioItemCostTracking.Settings.selectedCalculationType] || PortfolioItemCostTracking.Settings.calculationTypes.points;
    },
    getCalculationTypeDisplayName: function(){
        return PortfolioItemCostTracking.Settings.getCalculationTypeSettings().displayName || 'Unknown';
    },
    formatCost: function(cost){
        return Ext.util.Format.currency(cost,
            PortfolioItemCostTracking.Settings.currencySign,
            PortfolioItemCostTracking.Settings.currencyPrecision,
            PortfolioItemCostTracking.Settings.currencyEnd);
    },
    getCostPerUnit: function(project_ref){
        return PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref] || PortfolioItemCostTracking.Settings.normalizedCostPerUnit;
    },

    isProjectUsingNormalizedCost: function(project_ref){
        if (PortfolioItemCostTracking.Settings.projectCostPerUnit[project_ref]){
            return false;
        }
        return true;
    },
    /**
     * This function returns all the fields that we want to return for the tree. It is built depending on the settings for cost calculations so
     * that we know to include all necessary fields.
     * @param fetch
     * @returns {*}
     */
    getTreeFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }


       return Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.getStoryFetch(),
                                PortfolioItemCostTracking.Settings.getPortfolioItemFetch(),
                                (PortfolioItemCostTracking.Settings.getCalculationTypeSettings().requiredTaskFetch || []));

    },
    getStoryFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.requiredFetch,
                        PortfolioItemCostTracking.Settings.getCalculationTypeSettings().requiredStoryFetch);

    },
    getPortfolioItemFetch: function(fetch){
        if (!fetch){
            fetch = [];
        }

        return Ext.Array.merge(PortfolioItemCostTracking.Settings.requiredFetch,
            PortfolioItemCostTracking.Settings._getPreliminaryBudgetFields(),
            PortfolioItemCostTracking.Settings.requiredPortfolioItemFetch);

    },
    _getPreliminaryBudgetFields: function(){
        var preliminaryBudgetFields = [PortfolioItemCostTracking.Settings.preliminaryBudgetField];
        if (PortfolioItemCostTracking.Settings.preliminaryBudgetField === "PreliminaryEstimate"){
            preliminaryBudgetFields.push('Value');
        }
        return preliminaryBudgetFields;
    },
    getFields: function(config) {

        var current_calculation_type = (config && config.selectedCalculationType) || 'points',
            current_project_costs = (config && config.projectCostPerUnit) || {};

        var currency_store = Ext.create('Rally.data.custom.Store', {
            data: PortfolioItemCostTracking.Settings.currencyData
        });
        var labelWidth = 100;

        var cost_items = [];
        _.each(PortfolioItemCostTracking.Settings.calculationTypes, function(obj, key){
            cost_items.push({
                boxLabel: obj.label || key,
                name: 'selectedCalculationType',
                inputValue: key,
                disabled: obj.disabled || false,
                checked: key === current_calculation_type
            });
        });

        return [{
            xtype: 'rallycombobox',
            name: 'currencySign',
            store: currency_store,
            displayField: 'name',
            valueField: 'value',
            fieldLabel:  'Currency',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'numberfieldcombobox',
            name: 'preliminaryBudgetField',
            fieldLabel: 'Calculate Preliminary Budget using',
            model: 'PortfolioItem',
            labelWidth: labelWidth,
            margin: '10 0 10 0'
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Calculate Cost',
            columns: 1,
            vertical: true,
            labelWidth: labelWidth,
            margin: '10 0 10 0',
            items: cost_items
        },{
            xtype: 'rallytextfield',
            name: 'normalizedCostPerUnit',
            fieldLabel: 'Normalized Cost Per Unit',
            labelWidth: labelWidth,
            width: 200,
            margin: '25 0 0 0'
        },{
            xtype: 'costperprojectsettings',
            name: 'projectCostPerUnit',
            fieldLabel: 'Optionally define costs per unit for individual teams (exceptions to the normalized cost)',
            labelAlign: 'top',
            margin: '25 0 0 0',
            value: current_project_costs,
            readyEvent: 'ready'
        }];
    }
});
                Ext.define('PortfolioItemCostTracking.WsapiToolbox', {
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchModelTypePathByTypeDefinition: function(typeDef){
        var deferred = Ext.create('Deft.Deferred');
        var typeDefId = 0;
        if (typeDef){
            typeDefId = typeDef.replace('/typedefinition/','');
        }

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            fetch: ['TypePath','Name'],
            filters: [{
                property: 'ObjectID',
                value: typeDefId
            }]
        }).load({
            callback: function(records, operation, success){
                if (success && records && records.length > 0){
                    deferred.resolve(records[0].get('TypePath'));
                } else {
                    deferred.resolve(null); //(Ext.String.format("Error getting TypeDefinition for {1}: {0}", operation.error.errors.join(','), typeDef));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecordsWithPaging: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred'),
            pageSize = 200;

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            pageSize: pageSize
        });

        PortfolioItemCostTracking.WsapiToolbox.fetchWsapiCount(model, query_filters).then({
            success: function(totalRecords){
                var promises = [],
                    totalPages = Math.ceil(totalRecords/pageSize);

                for (var i=0; i< totalPages; i++){
                    promises.push(PortfolioItemCostTracking.WsapiToolbox.loadStorePage(i, store));
                }

                Deft.Promise.all(promises).then({
                    success: function(results){
                        deferred.resolve(_.flatten(results));
                    },
                    failure: function(msg){
                        deferred.reject(msg);
                    }
                });
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });

        return deferred;
    },
    loadStorePage: function(pageNum, store){
        var deferred = Ext.create('Deft.Deferred');

        store.loadPage(pageNum, {
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }

            }
        });

        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec === null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        return deferred;
    },
    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');
        console.log('fetchPortfolioItemTypes', new Date());
        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'TypeDefinition',
            fetch: ['TypePath', 'Ordinal','Name'],
            filters: [
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                },
                {
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                }
            ],
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }]
        });
        store.load({
            callback: function(records, operation, success){
                console.log('fetchPortfolioItemTypes callback', new Date());
                if (success){
                    var portfolioItemTypes = new Array(records.length);
                    _.each(records, function(d){
                        //Use ordinal to make sure the lowest level portfolio item type is the first in the array.
                        var idx = Number(d.get('Ordinal'));
                        portfolioItemTypes[idx] = { typePath: d.get('TypePath'), name: d.get('Name') };
                        //portfolioItemTypes.reverse();
                    });
                    deferred.resolve(portfolioItemTypes);
                } else {
                    var error_msg = '';
                    if (operation && operation.error && operation.error.errors){
                        error_msg = operation.error.errors.join(',');
                    }
                    deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                }
            }
        });
        return deferred.promise;
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        console.log('fetchDoneStates', new Date());
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        console.log('fetchDoneStates callback', new Date());
                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') == "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});

                Ext.define('PortfolioItemCostTracking.CostPerProjectSettings',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.costperprojectsettings',
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,

    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){

        this.callParent();
        this.addEvents('ready');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'Project',
            fetch: ['Name'],
            context: {
                project: null
            },
            limit: 'Infinity'
        });
        store.load({
            scope: this,
            callback: this._buildProjectGrid
        });

    },

    _buildProjectGrid: function(records, operation, success){

        var decodedValue = {};
        if (this.initialConfig && this.initialConfig.value && !_.isEmpty(this.initialConfig.value)){
            if (!Ext.isObject(this.initialConfig.value)){
                decodedValue = Ext.JSON.decode(this.initialConfig.value);
            } else {
                decodedValue = this.initialConfig.value;
            }
        }

        var data = [],
            empty_text = "No exceptions";

        if (success) {
            _.each(records, function(project){
                var cost = decodedValue[project.get('_ref')] || null;
                if (cost){
                    data.push({projectRef: project.get('_ref'), projectName: project.get('Name'), cost: cost});
                }
            });
        } else {
            empty_text = "Error(s) fetching Project data: <br/>" + operation.error.errors.join('<br/>');
        }

        var custom_store = Ext.create('Ext.data.Store', {
            fields: ['projectRef', 'projectName', 'cost'],
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
           // showRowActionsColumn: false,
            showPagingToolbar: false,
            store: custom_store,
            maxHeight: 300,
            margin: '20 0 0 0',
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        var width = Math.max(this.inputEl.getWidth(true),300);

        Ext.create('Rally.ui.Button',{
            text: 'Select Projects',
            renderTo: this.inputEl,
            margin: '10 0 0 0',
            listeners: {
                scope: this,
                click: function(){

                    Ext.create('ProjectPickerDialog',{
                        autoShow: true,
                        maxHeight: 400,
                        maxWidth: 400,
                        width: Math.min(width, 400),
                        title: 'Choose Project',
                        selectedRefs: _.pluck(data, 'projectRef'),
                        listeners: {
                            scope: this,
                            itemschosen: function(items){
                                var new_data = [],
                                    store = this._grid.getStore();

                                _.each(items, function(item){
                                    if (!store.findRecord('projectRef',item.get('_ref'))){
                                        new_data.push({
                                            projectRef: item.get('_ref'),
                                            projectName: item.get('Name'),
                                            cost: null
                                        });
                                    }
                                });
                                this._grid.getStore().add(new_data);
                            }
                        }
                    });
                }
            }
        });

       this.fireEvent('ready', true);
    },
    _removeProject: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            scope: this,
            rowActionsFn: function(record){
                return  [
                    {text: 'Remove', record: record, handler: me._removeProject, grid: me._grid }
                ];
            },
            //Need to override this since we are using a custom store
            _renderGearIcon: function(value, metaData, record) {
                return '<div class="row-action-icon icon-gear"/>';
            }
        },{
                text: 'Project',
                dataIndex: 'projectRef',
                flex: 1,
                editor: false,
                renderer: function(v, m, r){
                    return r.get('projectName');
                },
                getSortParam: function(v,m,r){
                    return 'projectName';
                }
        },{
            text: 'Cost Per Unit',
            dataIndex: 'cost',
            editor: {
                xtype: 'rallynumberfield'
            },
            renderer: function(v){
                if (v && v > 0){
                    return v;
                }
                return "Use Default";
            }
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._buildSettingValue());
        return data;
    },
    _buildSettingValue: function() {
        var mappings = {};
        var store = this._grid.getStore();

        store.each(function(record) {
            if (record.get('cost') && record.get('projectRef')) {
                mappings[record.get('projectRef')] = record.get('cost');
            }
        }, this);
        return mappings;
    },

    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    },
    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }
});

                Ext.define('PortfolioItemCostTracking.PortfolioRollupItem',{

    _rollupDataPreliminaryBudget: undefined,
    _rollupDataTotalCost: undefined,
    _rollupDataActualCost: undefined,
    _rollupDataRemainingCost: undefined,
    _rollupDataToolTip: null,
    _notEstimated: true,
    children: undefined,

    projectCosts: undefined,
    useBudgetCalc: false,

    constructor: function(record) {
        this._rollupDataTotalCost = 0;
        this._rollupDataActualCost = 0;
        this._rollupDataRemainingCost = 0;

        this.parent = record.get('Parent') && record.get('Parent').ObjectID || null;
        this.objectID = record.get('ObjectID');

        this._rollupDataPreliminaryBudget = this._calculatePreliminaryBudget(record.getData());
        this._rollupDataTotalCost = this.getPreliminaryBudget();
        this._rollupDataToolTip = this.getTooltip();

        Ext.apply(this, record.getData());
    },
    addChild: function(objectID){
        if (!this.children){
            this.children = [];
        }
        this.children.push(objectID);
    },
    getExportRow: function(columns, ancestors){
        var rec = Ext.clone(ancestors);

        rec[this._type] = this.FormattedID;

        rec.type = PortfolioItemCostTracking.Settings.getTypePathDisplayName(this._type);
        _.each(columns, function(c){
            var field = c.costField || c.dataIndex || null;
            if (field){
                var data = this[field];
                if (Ext.isObject(data)){
                    rec[field] = data._refObjectName;
                } else if (Ext.isDate(data)){
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                } else {
                    rec[field] = data;
                }
            }
        }, this);
        return rec;
    },
    _calculatePreliminaryBudget: function(data){
        var preliminaryBudgetField = PortfolioItemCostTracking.Settings.preliminaryBudgetField;

        if (data && data[preliminaryBudgetField]){
            //We need to do this in case we are using hte PreliminaryEstimate field, which is an object
            var val = data[preliminaryBudgetField].Value || data[preliminaryBudgetField];
            var cpu = PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);
            return cpu * val;
        }
        return null;
    },
    getTooltip: function(){

        var completed  = PortfolioItemCostTracking.Settings.notAvailableText;
        if ((this.__actualUnits >= 0) && (this.__totalUnits >=0 )){
            completed = Ext.String.format("{0}/{1}", this.__actualUnits, this.__totalUnits);
        }

        var calc_type_name = PortfolioItemCostTracking.Settings.getCalculationTypeDisplayName();

        var html = Ext.String.format('{0} completed {1}<br/>', calc_type_name, completed);
        if (this.projectCosts){
            html += '<br/>Cost per unit:<br/>';
            _.each(this.projectCosts, function(project_cost, project_name){
                html += Ext.String.format('{0} {1}<br/>', PortfolioItemCostTracking.Settings.formatCost(project_cost), project_name);
            });
        }


        if (this._notEstimated){
            html += '<br/><p>Portfolio Item has missing ' + calc_type_name + '.  Preliminary Budget is being used to calculate Projected and Remaining costs.</p>';
        }
        return html;
    },
    getTotalCostRollup: function(){
        if (this._notEstimated){
            return this.getActualCostRollup() + this.getRemainingCostRollup();
        }
        return this._rollupDataTotalCost;
    },
    getActualCostRollup: function(){
        return this._rollupDataActualCost;
    },
    getRemainingCostRollup: function(){
        if (this._notEstimated){
            return this.getPreliminaryBudget() - this.getActualCostRollup();
        }
        return this._rollupDataRemainingCost;
    },
    getPreliminaryBudget: function(){
        return this._rollupDataPreliminaryBudget;
    }
});


Ext.define('PortfolioItemCostTracking.UpperLevelPortfolioRollupItem',{
    extend: 'PortfolioItemCostTracking.PortfolioRollupItem',


    processChildren: function(){

        var rollupDataTotal = 0,
            rollupDataActual = 0,
            rollupDataRemaining = 0,
            totalUnitsSum = 0,
            actualUnitsSum = 0,
            projectCosts = {},
            rollupItems = this.children || [],
            notEstimated = false;

        Ext.Array.each(rollupItems, function(item){
            item.processChildren();

            rollupDataTotal += item.getTotalCostRollup() ;
            rollupDataActual +=  item.getActualCostRollup();
            rollupDataRemaining += item.getRemainingCostRollup();
            totalUnitsSum += item.__totalUnits || 0;
            actualUnitsSum += item.__actualUnits || 0;
            projectCosts = Ext.merge(projectCosts, item.projectCosts || {});
            notEstimated = notEstimated && item._notEstimated;

        }, this);

        this._notEstimated = notEstimated;
        this._rollupDataTotalCost = rollupDataTotal;
        this._rollupDataActualCost = rollupDataActual;
        this._rollupDataRemainingCost = rollupDataRemaining;
        this.projectCosts = projectCosts;
        this.__totalUnits = totalUnitsSum;
        this.__actualUnits = actualUnitsSum;
        this._rollupDataToolTip = this.getTooltip();

    }
});

Ext.define('PortfolioItemCostTracking.LowestLevelPortfolioRollupItem',{
    extend: 'PortfolioItemCostTracking.PortfolioRollupItem',

    processChildren: function(){
        if (!this.children || this.children.length ===0){
            return;
        }

        var objectID = this.objectID,
            rollupDataTotal = 0,
            rollupDataActual = 0,
            totalUnitsSum = 0,
            actualUnitsSum = 0,
            projectCosts = {};

        for (var i=0; i< this.children.length ; i++){
            var childData = this.children[i];

            if (childData.PortfolioItem && childData.PortfolioItem.ObjectID === objectID) {

                var totalUnits = childData.__totalUnits, //totalFn(childData) || 0,
                    actualUnits = childData.__actualUnits;  //actualFn(childData) || 0;

                totalUnitsSum += totalUnits;
                actualUnitsSum += actualUnits;
                projectCosts = this._updateProjectNameAndCostHash(projectCosts, childData.Project);


                rollupDataTotal += childData._rollupDataTotalCost;
                rollupDataActual += childData._rollupDataActualCost;
            }
        }

        this._notEstimated = (totalUnitsSum === 0);
        if (this._notEstimated && this.getPreliminaryBudget() > this.getActualCostRollup()){
            this._rollupDataRemainingCost = this.getPreliminaryBudget() - this.getActualCostRollup();
            this._rollupDataTotalCost = this._rollupDataActualCost + this._rollupDataRemainingCost;
        } else {
            this._rollupDataTotalCost = rollupDataTotal;
            this._rollupDataRemainingCost = rollupDataTotal  - rollupDataActual;
        }
        this.__totalUnits = totalUnitsSum;
        this.__actualUnits = actualUnitsSum;

        this._rollupDataActualCost = rollupDataActual;
        this.projectCosts = projectCosts;
        this._rollupDataToolTip = this.getTooltip();

    },
    _updateProjectNameAndCostHash: function(projectCosts, project){

        projectCosts = projectCosts || {};

        var name = project._refObjectName,
            cost = PortfolioItemCostTracking.Settings.getCostPerUnit(project._ref);

        if (PortfolioItemCostTracking.Settings.isProjectUsingNormalizedCost(project._ref)){
            name =  "normalized (default)";
        }
        projectCosts[name] = cost;
        return projectCosts;
    }
});

Ext.define('PortfolioItemCostTracking.UserStoryRollupItem', {
    extend: 'PortfolioItemCostTracking.PortfolioRollupItem',
    constructor: function(record, totalFn, actualFn) {
        var data = record.getData();
        this.__totalUnits = totalFn(data);
        this.__actualUnits = actualFn(data);
        this._notEstimated = false;
        var costPerUnit = PortfolioItemCostTracking.Settings.getCostPerUnit(data.Project._ref);

        this._rollupDataTotalCost = (this.__totalUnits * costPerUnit) || 0;
        this._rollupDataActualCost = (this.__actualUnits * costPerUnit) || 0;
        this._rollupDataRemainingCost = this._rollupDataTotalCost - this._rollupDataActualCost;

        this.parent = record.get('PortfolioItem') && record.get('PortfolioItem').ObjectID || null;
        this.objectID = data.ObjectID;

        this._rollupDataPreliminaryBudget = null;
        this._rollupDataToolTip = null;

        Ext.apply(this, data);
    }
});

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('PortfolioItemCostTracking.RollupCalculator', {
        extend: 'Ext.Base',

        mixins: {
            observable: 'Ext.util.Observable'
        },

        rollupItems: {},

        constructor: function (config) {
            this.mixins.observable.constructor.call(this, config);
            this.portfolioItemTypes = PortfolioItemCostTracking.Settings.getPortfolioItemTypes();
        },
        addRollupRecords: function(portfolioItemRecordHash, stories){
            for (var i=this.portfolioItemTypes.length -1; i >= 0; i--){
                var portfolioRecords = portfolioItemRecordHash[this.portfolioItemTypes[i]] || [];
                this._addPortfolioRecords(portfolioRecords);
            }
            console.log('addRollupRecords._addStories', new Date());
            this._addStories(stories);
             this._calculatePortfolioItemRollups();
            console.log('addRollupRecords. DONE', new Date());
        },
        getRollupData: function(record){
            if (!record){
                return null;
            }
            var objectID = record.ObjectID || record.get('ObjectID');
            return this.rollupItems[objectID] || null;
        },
        /**
         * Adds records needed to calculate the rollup data
         * @param records
         */
        _addPortfolioRecords: function(records){
            if (!records || records.length === 0){
                return;
            }

            var type = records[0].get('_type').toLowerCase(),
                rollupItemType = PortfolioItemCostTracking.Settings.getRollupItemType(type);

            if (rollupItemType){ //this is a portfolio item type
                for (var i=0; i<records.length; i++){
                    var r = records[i],
                        parentObjectID = r.get('Parent') && r.get('Parent').ObjectID,
                        item = Ext.create(rollupItemType, r);

                    this.rollupItems[r.get('ObjectID')] = item;

                    if (parentObjectID && this.rollupItems[parentObjectID]){
                        this.rollupItems[parentObjectID].addChild(item);
                    }
                }
            }
        },

        _addStories: function(stories){
            var parents = [],
                rollupItems = this.rollupItems,
                totalFn = PortfolioItemCostTracking.Settings.getCalculationTypeSettings().totalUnitsForStoryFn,
                actualFn = PortfolioItemCostTracking.Settings.getCalculationTypeSettings().actualUnitsForStoryFn;

            for(var i =0; i < stories.length; i++){
                var item = Ext.create('PortfolioItemCostTracking.UserStoryRollupItem', stories[i], totalFn, actualFn);

                this.rollupItems[item.ObjectID] = item;

                if (item.parent && this.rollupItems[item.parent]){
                    parents.push(item.parent);
                    this.rollupItems[item.parent].addChild(item);
                }
            }
            _.each(parents, function(objectID){
                if (rollupItems[objectID]){
                    rollupItems[objectID].processChildren();
                }
            });
        },
        _calculatePortfolioItemRollups: function(){
           _.each(this.rollupItems, function(item){
                if (item && !item.parent && /^portfolioitem/.test(item._type)){
                    item.processChildren();
                }
            });
        },
        updateModels: function(records){
            records = records || [];
            var unloadedModels = [];
            _.each(records, function(r){
                var rollupItem = this.rollupItems[r.get('ObjectID')] || null;
                if (rollupItem){
                    console.log('r.get', r.get('_rollupData'));
                    r.set('_rollupData', rollupItem);
                } else {
                    unloadedModels.push(r);
                }

            }, this);
            return unloadedModels;
        }
    });
}) ();
                Ext.override(Rally.ui.grid.TreeGrid, {
    _mergeColumnConfigs: function(newColumns, oldColumns) {

        var mergedColumns = _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, {dataIndex: this._getDataIndex(newColumn)});
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);

        mergedColumns = mergedColumns.concat(this.config.derivedColumns);
        return mergedColumns;
    }
});
                Ext.define('PortfolioItemCostTracking.promise.ParallelThrottle',{
    requires: ['Deft.promise.Promise'],
    statics: {

        throttle: function (fns, maxParallelCalls, scope) {

            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }


            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        }
    }
});

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Class to load lots of data and update as status is made.
     */
    Ext.define('PortfolioItemCostTracking.RollupDataLoader', {
        extend: 'Ext.Base',

        mixins: {
            observable: 'Ext.util.Observable'
        },

        context: undefined,
        promise: undefined,

        constructor: function (config) {
            console.log('loader', this, config);
            this.mixins.observable.constructor.call(this, config);

            this.context = config && config.context || null;

            this.additionalFetch = config && config.additionalFetch || [];
        },
        load: function(rootRecords){

            if (!rootRecords || rootRecords.length === 0){
                return;
            }
            this.rootRecords = rootRecords;

            if (this._getPortfolioItemLevelsToFetch() > 0){

                this._fetchPortfolioItems();
            } else {
                this._fetchStories();
            }
        },
        _fetchStories: function(portfolioItemHash){
            var me = this;

            me.fireEvent('statusupdate',"Loading Stories");
            var portfolioRootLevel = me._getPortfolioItemLevelsToFetch();
            me.fetchWsapiRecordsWithPaging(me._getStoryConfig(portfolioRootLevel)).then({
                success: function(stories){
                    me.fireEvent('statusupdate',"Processing data");
                    //Setting a timeout here so that the processing data status update shows up
                    setTimeout(function() {me.fireEvent('rollupdataloaded', portfolioItemHash || {}, stories);}, 50);
                },
                failure: function(msg){
                    me.fireEvent('loaderror', 'Error fetching stories: ' + msg);
                },
                scope: this
            });

        },

        _fetchPortfolioItems: function(){
            var promises = [],
                portfolioRootLevel = this._getPortfolioItemLevelsToFetch();

            this.fireEvent('statusupdate',"Loading Portfolio Items");

            for (var i = 0; i <= portfolioRootLevel; i++){
                promises.push(this.fetchWsapiRecordsWithPaging(this._getPortfolioItemConfig(i, portfolioRootLevel)));
            }

            Deft.Promise.all(promises).then({
                success: function(results){
                    var recordHash = {};
                    _.each(results, function(records){
                        if (records && records.length > 0){
                            recordHash[records[0].get('_type')] = records;
                        }
                    });
                    this._fetchStories(recordHash);
                },
                failure: function(msg){
                    this.fireEvent('loaderror', 'Error fetching portfolio items: ' + msg);
                },
                scope: this
            });

        },
        _getPortfolioItemLevelsToFetch: function(){
            var type = this.rootRecords[0].get('_type'),
                portfolioRootLevel = PortfolioItemCostTracking.Settings.getPortfolioItemTypeLevel(type);

            return portfolioRootLevel;
        },
        _getStoryConfig: function(portfolioRootLevel){
            console.log('storefetch', PortfolioItemCostTracking.Settings.getStoryFetch(this.additionalFetch));
           return {
                model: 'hierarchicalrequirement',
                fetch: PortfolioItemCostTracking.Settings.getStoryFetch(this.additionalFetch),
                filters: this._buildFetchFilter(-1, portfolioRootLevel),
               statusDisplayString: "Loading data for {0} User Stories",
               completedStatusDisplayString: "Processing data"
            };
        },
        _getPortfolioItemConfig: function(idx, portfolioRootLevel){

            return {
                model: PortfolioItemCostTracking.Settings.getPortfolioItemTypes()[idx],
                fetch: PortfolioItemCostTracking.Settings.getPortfolioItemFetch(this.additionalFetch),
                filters: this._buildFetchFilter(idx, portfolioRootLevel),
                statusDisplayString: "Loading data for {0} Portfolio Items"
            };
        },
        _buildParentLevelString: function(idx, portfolioRootLevel){
            console.log('_buildParentLevelString', idx, portfolioRootLevel);
            var startIdx = idx,
                parentStringArray = [];

            if (idx < 0){
                startIdx = 0;
                parentStringArray.push("PortfolioItem");
            }

            parentStringArray = parentStringArray.concat(_.range(startIdx, portfolioRootLevel).map(function(){ return 'Parent'; }));
            parentStringArray.push("ObjectID");
            return parentStringArray.join('.');
        },
        _buildFetchFilter: function(idx, portfolioRootLevel){
            var records = this.rootRecords,
                parentLevelString = this._buildParentLevelString(idx, portfolioRootLevel),
                filters = _.map(records, function(r){ return {property: parentLevelString, value: r.get('ObjectID')}; });

            return Rally.data.wsapi.Filter.or(filters);
        },

        fetchlookback: function(ancestorOids, fetchList, typeHierarchy){
            var deferred = Ext.create('Deft.Deferred');

            fetchList = fetchList.concat(['_ItemHierarchy','_TypeHierarchy']);
            console.log('fetchlookback', ancestorOids, fetchList, typeHierarchy);
            Ext.create('Rally.data.lookback.SnapshotStore', {
                fetch: fetchList,
                find: {
                    _ItemHierarchy: {$in: ancestorOids},
                    __At: "current",
                    _TypeHierarchy: typeHierarchy
                },
                hydrate: ['_TypeHierarchy'],
                limit: 'Infinity',
                removeUnauthorizedSnapshots: true
            }).load({
                callback: function(records, operation, success){
                    console.log('lookback', records, operation, success);
                    deferred.resolve(records);
                }
            });

            return deferred;
        },
        cancel: function(){
            if ((this.promise && this.promise.getState() === 'pending')){
                this.promise.cancel();
                this.fireEvent('loadcancelled');
            }
        },
        fetchWsapiCount: function(model, query_filters){
            var deferred = Ext.create('Deft.Deferred');

            Ext.create('Rally.data.wsapi.Store',{
                model: model,
                fetch: ['ObjectID'],
                filters: query_filters,
                limit: 1,
                pageSize: 1
            }).load({
                callback: function(records, operation, success){
                    if (success){
                        deferred.resolve(operation.resultSet.totalRecords);
                    } else {
                        deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                    }
                }
            });
            return deferred;
        },
        fetchWsapiRecordsWithPaging: function(config){
            var deferred = Ext.create('Deft.Deferred'),
                promises = [],
                me = this;

            this.fetchWsapiCount(config.model, config.filters).then({
                success: function(totalCount){
                    var store = Ext.create('Rally.data.wsapi.Store',{
                        model: config.model,
                        fetch: config.fetch,
                        filters: config.filters,
                        pageSize: 200
                    }),
                        totalPages = Math.ceil(totalCount/200);

                    var pages = _.range(1,totalPages+1,1);

                    this.fireEvent('statusupdate',Ext.String.format(config.statusDisplayString || "Loading {0} artifacts", totalCount));

                    _.each(pages, function(page){
                        promises.push(function () {return me.loadStorePage(page, store);});
                    });

                    PortfolioItemCostTracking.promise.ParallelThrottle.throttle(promises, 12, me).then({
                        success: function(results){
                            deferred.resolve(_.flatten(results));
                        },
                        failure: function(msg){
                            deferred.reject(msg);
                        },
                        scope: me
                    });
                },
                failure: function(msg){
                    deferred.reject(msg);
                },
                scope: me
            });
            return deferred;
        },
        loadStorePage: function(pageNum, store){
            var deferred = Ext.create('Deft.Deferred');

            store.loadPage(pageNum, {
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                         deferred.resolve(records);
                    } else {
                        deferred.reject('loadStorePage error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
            });

            return deferred;
        }
    });
})();
                

Ext.define('ProjectPickerDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.projectpickerdialog',


    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemschosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemschosen', this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },
    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }
        Ext.create('Rally.data.wsapi.ProjectTreeStoreBuilder').build({
            models: ['project'],
            autoLoad: true,
            enableHierarchy: true,
            filters: [{
                property: 'Parent',
                value: ""
            }]
        }).then({
            scope: this,
            success: function(store) {

                var mode = this.multiple ? 'MULTI' : 'SINGLE';

                var checkbox_model = Ext.create('Rally.ui.selection.CheckboxModel', {
                    mode: mode,
                    enableKeyNav: false,
                    allowDeselect: true
                });

                this.grid = this.add({
                    xtype: 'rallytreegrid',
                    treeColumnDataIndex: 'Name',
                    treeColumnHeader: 'Name',
                    viewConfig: {
                        cls: 'grid-view-bulk-edit'
                    },
                    enableRanking: false,
                    enableEditing: false,
                    enableBulkEdit: false,
                    shouldShowRowActionsColumn: false,

                    selModel: checkbox_model,
                    _defaultTreeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                        store = store.treeStore || store;
                        return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('Name')).apply(record.data);
                    },
                    columnCfgs: [],
                    store: store
                });

                this.mon(this.grid, {
                    beforeselect: this._onGridSelect,
                    beforedeselect: this._onGridDeselect,
                    load: this._onGridLoad,
                    scope: this
                });
                this.add(this.grid);
                this._onGridReady();
            }
        });
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);

        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }
        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },
    _onGridLoad: function() {
        //console.log('_onGridLoad');
        var store = this.grid.store;
        var records = [];
        _.each(this.selectionCache, function(record) {
            var foundNode = store.getRootNode().findChild('_ref', record.get('_ref'),true);

            if (foundNode) {
                records.push(foundNode);
            }
        });
        if (records.length) {
            this.grid.getSelectionModel().select(records);
        }
    },
    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        //Filter functions call store load so we don't need to refresh the selections becuaes the
        //onGridLoad function will
        if (terms) {
            store.filter([
                Ext.create('Rally.data.wsapi.Filter',{
                    property: 'Name',
                    operator: 'contains',
                    value: terms
                })
            ]);
        } else {
            store.clearFilter();
        }

    },
    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});

Ext.override(Rally.data.wsapi.ParentChildMapper, {
    constructor: function() {
        this.parentChildTypeMap = {
            project: [{
                typePath: 'project', collectionName: 'Children', parentField: 'Parent'
            }],
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };
    }
});


Ext.define('Rally.data.wsapi.ProjectTreeStore', {

    // Client Metrics Note: WsapiTreeStore is too low level to record its load begins/ends. The problem is
    // client metrics can only reliably keep track of one load per component at a time. WsapiTreeStore makes
    // no guarantee that only one load will happen at a time. It's better to measure the component that is using
    // the store. All is not lost, the actual data requests that WsapiTreeStore makes *are* measured by client metrics.

    requires: [
        'Deft.promise.Deferred',
        'Rally.data.ModelFactory',
        'Rally.ui.grid.data.NodeInterface',
        'Rally.data.ModelTypes',
        'Rally.data.wsapi.ParentChildMapper'
    ],
    extend: 'Rally.data.wsapi.TreeStore',
    alias: 'store.rallyprojectwsapitreestore',

    /**
     * The type definition typePaths to render as root items (required)
     * @cfg {String[]} parentTypes
     */
    parentTypes: ['project'],

    /**
     * @property
     * @private
     */
    childLevelSorters: [{
        property: 'Name',
        direction: 'ASC'
    }],

    getParentFieldNamesByChildType: function(childType, parentType) {
        var model = this.model; //.getArtifactComponentModel(childType);
        return _.transform(this.mapper.getParentFields(childType, parentType), function(acc, field) {
            var typePath = field.typePath,
                fieldName = field.fieldName,
            // hasFieldModel = this.model.getArtifactComponentModel(typePath) || model.hasField(fieldName);
                hasFieldModel = model.hasField(fieldName);

            if (hasFieldModel) {
                acc.push(fieldName.replace(/\s+/g, ''));
            }
        }, [], this);
    },

    filter: function(filters) {
        this.fireEvent('beforefilter', this);
        //We need to clear the filters to remove the Parent filter
        this.filters.clear();
        this.filters.addAll(filters);
        this._resetCurrentPage();
        this.load();
    },

    clearFilter: function(suppressEvent) {
        this._resetCurrentPage();
        this.filters.clear();
        //We need to add the parent filter back in
        this.filters.addAll(Ext.create('Rally.data.wsapi.Filter',{
            property: 'Parent',
            value: ''
        }));

        if (!suppressEvent) {
            this.load();
        }
    }
});

Ext.define('Rally.data.wsapi.ProjectTreeStoreBuilder', {
    extend: 'Rally.data.wsapi.TreeStoreBuilder',

    build: function(config) {
        //A context needs to be passed in here, and it NEEDS to be a DataContext (context.getDataContext())
        //otherwise you will get a bunch of garbage on your WSAPI request

        config = _.clone(config || {});
        config.storeType = 'Rally.data.wsapi.ProjectTreeStore';

        return this.loadModels(config).then({
            success: function(models) {
                models = _.values(models);
                return this._buildStoreWithModels(models, config);
            },
            scope: this
        });
    }
});
                

Ext.define('Ext.CostTemplate', {
    extend: 'Ext.grid.column.Template',
    alias: ['widget.costtemplatecolumn'],

    align: 'right',

    initComponent: function(){
        var me = this;

        Ext.QuickTips.init();

        me.tpl = new Ext.XTemplate('<tpl><div data-qtip="{[this.getTooltip(values)]}" style="cursor:pointer;text-align:right;">{[this.getCost(values)]}</div></tpl>',{
            costField: me.costField,

            getCost: function(values){
                if (values[this.costField] === null){
                    return PortfolioItemCostTracking.Settings.notAvailableText;
                } else {
                    var html = PortfolioItemCostTracking.Settings.formatCost(values[this.costField] || 0);
                    if (values._notEstimated && this.costField === '_rollupDataTotalCost'){
                        html = '<span class="picto icon-warning warning" style="color:#FAD200;font-size:10px;"></span>' + html;
                    }
                    return html;
                }
            },
            getTooltip: function(values){
                if (values._rollupDataToolTip){
                    return values._rollupDataToolTip;
                }
                return '';
            }

        });
        me.hasCustomRenderer = true;
        me.callParent(arguments);
    },
    getValue: function(){
        return values[this.costField] || 0;
    },
    defaultRenderer: function(value, meta, record) {
        var data = Ext.apply({}, record.data._rollupData); //, record.getAssociatedData());
        return this.tpl.apply(data);
    }
});

/**
 * Extended the cost template column class for each specific type
 * becuase if I pass in a custom property (eg costField), it
 * gets lost when the columns refresh
 *
 */

Ext.define('Ext.ActualCostTemplate',{
    extend: 'Ext.CostTemplate',
    alias: ['widget.actualcosttemplatecolumn'],
    costField: '_rollupDataActualCost'
});

Ext.define('Ext.TotalCostTemplate',{
    extend: 'Ext.CostTemplate',
    alias: ['widget.totalcosttemplatecolumn'],
    costField: '_rollupDataTotalCost'
});

Ext.define('Ext.RemainingCostTemplate',{
    extend: 'Ext.CostTemplate',
    alias: ['widget.remainingcosttemplatecolumn'],
    costField: '_rollupDataRemainingCost'
});

Ext.define('Ext.PreliminaryBudgetTemplate',{
    extend: 'Ext.CostTemplate',
    alias: ['widget.preliminarybudgettemplatecolumn'],
    costField: '_rollupDataPreliminaryBudget'
});
                
Ext.define('TreeGridContainerCustomFilterControl', {
    alias: 'plugin.treegridcontainercustomfiltercontrol',
    extend:'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',

    showControl: function() {
        if (!this.controlCmp) {
            this._createControlCmp();
        }

        if (this.controlCmp) {
            this.controlCmp.show();
        }

        return this.controlCmp;
    }
});

                    Ext.define('TreeGridContainerFieldPicker', {
        alias: 'plugin.treegridcontainerfieldpicker',
        extend:'Ext.AbstractPlugin',
        mixins: ['Rally.ui.gridboard.plugin.GridBoardControlShowable'],
        requires: [
            'Rally.ui.popover.Popover',
            'Rally.ui.Button',
            'Rally.ui.picker.FieldPicker'
        ],

        /**
         * @cfg {String[]} alwaysSelectedFields
         * The fields that will be always selected in the field picker for the grid view
         */
        gridAlwaysSelectedValues: ['FormattedID', 'Name'], // DragAndDropRank gets added in init if Drag and Drop is enabled for the workspace in the component's context

        /**
         * @cfg {String[]} gridFieldBlackList
         * The fields that will be blacklisted in grid mode
         */
        gridFieldBlackList: [
            'Actuals',
            'Changesets',
            'Children',
            'Description',
            'Notes',
            'ObjectID',
            'Predecessors',
            'RevisionHistory',
            'Subscription',
            'Successors',
            'TaskIndex',
            'Workspace',
            'VersionId'
        ],

        /**
         * @cfg {String[]}
         * the names of the models displayed on the board.
         */
        modelNames: [],

        stateful: true,

        margin: '3 9 10 10',

        constructor: function (config) {
            config.gridFieldBlackList = _.union(this.gridFieldBlackList, config.gridFieldBlackList);
            config.gridAlwaysSelectedValues = _.union(this.gridAlwaysSelectedValues, config.gridAlwaysSelectedValues);
            this.callParent(arguments);
        },

        init: function(cmp) {
            this.callParent(arguments);
            this.cmp = cmp;

            var rankingEnabled = this.cmp.getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled && cmp.gridConfig.enableRanking !== false;

            this.gridAlwaysSelectedValues = this._modifyFieldCollection(this.gridAlwaysSelectedValues, ['DragAndDropRank'], rankingEnabled);
            this.gridFieldBlackList = this._modifyFieldCollection(this.gridFieldBlackList, ['DragAndDropRank'], !rankingEnabled);
            this.stateId = this.stateId || this.cmp.getFieldListStateId();

            var state = Ext.state.Manager.get(this.stateId);
            this._fields = state && state.fields;

            this.showControl();
        },
        showControl: function() {
            if (!this.controlCmp) {
                this._createControlCmp();
            }

            if (this.controlCmp) {
                this.controlCmp.show();
            }

            return this.controlCmp;
        },
        _modifyFieldCollection: function (collection, fields, include) {
            if (include) {
                return _.union(collection, fields);
            }
            return _.reject(collection, function (field) { return _.contains(fields, field); });
        },

        getControlCmpConfig: function() {
            return {
                xtype: "rallybutton",
                itemId: 'fieldpickerbtn',
                cls: 'field-picker-btn secondary rly-small',
                margin: this.margin,
                iconCls: 'icon-add-column',
                toolTipConfig: {
                    html: this.getTitle(),
                    anchor: 'top'
                },
                listeners: {
                    click: this._onClick,
                    scope: this
                }
            };
        },

        _onClick: function(btn) {
            this._createPopover(btn.getEl());
        },

        _getPickerConfig: function() {
            var pickerConfig;

            pickerConfig = _.extend({
                value: _.pluck(this.cmp.getGrid().columns, 'dataIndex').join(','),
                fieldBlackList: this.gridFieldBlackList,
                alwaysSelectedValues: this.gridAlwaysSelectedValues
            }, this.fieldPickerConfig);

            return pickerConfig;
        },

        _createPopover: function(popoverTarget) {
            this.popover = Ext.create('Rally.ui.popover.Popover', {
                target: popoverTarget,
                placement: ['bottom', 'left', 'top', 'right'],
                cls: 'field-picker-popover',
                toFront: Ext.emptyFn,
                buttonAlign: 'center',
                title: this.getTitle(),
                listeners: {
                    destroy: function () {
                        this.popover = null;
                    },
                    scope: this
                },
                buttons: [
                    {
                        xtype: "rallybutton",
                        text: 'Apply',
                        cls: 'field-picker-apply-btn primary rly-small',
                        listeners: {
                            click: function() {
                                this._onApply(this.popover);
                            },
                            scope: this
                        }
                    },
                    {
                        xtype: "rallybutton",
                        text: 'Cancel',
                        cls: 'field-picker-cancel-btn secondary dark rly-small',
                        listeners: {
                            click: function() {
                                this.popover.close();
                            },
                            scope: this
                        }
                    }
                ],
                items: [
                    _.extend({
                        xtype: 'rallyfieldpicker',
                        cls: 'field-picker',
                        itemId: 'fieldpicker',
                        modelTypes: this._getModelTypes(),
                        alwaysExpanded: true,
                        width: 200,
                        placeholderText: 'Search',
                        selectedTextLabel: 'Selected',
                        availableTextLabel: 'Available',
                        listeners: {
                            specialkey: function(field, e) {
                                if (e.getKey() === e.ESC) {
                                    this.popover.close();
                                }
                            },
                            scope: this
                        }
                    }, this._getPickerConfig())
                ]
            });
        },

        _getModelTypes: function() {
            return _.pluck(this._getModels(), 'typePath');
        },

        _getModels: function() {
            return _.reduce(this.cmp.getModels(), function(accum, model) {
                if (model.typePath === 'artifact') {
                    accum = accum.concat(model.getArtifactComponentModels());
                } else {
                    accum.push(model);
                }
                return accum;
            }, []);
        },


        getTitle: function () {
            return 'Show Columns';
        },

        /**
         * Update the fields displayed. In grid mode this will be the columns displayed. In board mode it will be
         * the fields on the cards
         *
         * @param {String[]|Object[]} fields A list of field names to display
         * @param {Boolean} true to suspend store load if it will be triggered elsewhere
         */
        updateFields: function (fields, suspendLoad) {
            this._fields = _.map(fields, function (field) {
                return field.get('name');
            });

            this.cmp.updateFields(this._fields, false, suspendLoad);

            this._updatePickerValue(this._fields);

        },

        _updatePickerValue: function(fields) {
            if (this.popover && this.popover.down('rallyfieldpicker')) {
                this.popover.down('rallyfieldpicker').setValue(this._fields.join(','));
            }
        },

        _onApply: function(popover) {
            var fieldPicker = popover.down('rallyfieldpicker');

            this.updateFields(fieldPicker.getValue());

            popover.close();
        }
    });

                Ext.define('TreeGridContainer', {
    extend: 'Ext.Container',
    mixins: ['Rally.app.Scopeable'],
    requires: [
        'Rally.ui.LeftRight',
        'Rally.ui.grid.TreeGrid'
    ],

    alias: 'widget.treegridcontainer',
    cls: 'rui-gridboard',
    /**
     * @cfg {Object}
     * Common store configuration properties
     * to be applied to both the board and grid views
     */
    storeConfig: {},
    gridConfig: {},
    /**
     * @cfg {Array}
     * An array of model names of types to view on the grid board.
     */
    modelNames: [],
    /**
     * @inheritdoc
     */
    layout: {
        type: 'auto'
    },

    fieldListStateId: 'shownFields',

    currentCustomFilter: [],



    items: [
        {
            itemId: 'header',
            xtype: 'rallyleftright',
            padding: '4 10 10 10',
            overflowX: 'hidden'
        }
    ],
    initComponent: function () {
        this.plugins = this.plugins || [];
        this.stateId = this.getAppContextOrEnvironmentContext().getScopedStateId(this.stateId);

        this.callParent(arguments);

        this.addEvents([
        /**
         * @event load
         * Fires when the data store for the grid or board has loaded.
         * @param {Rally.ui.gridboard.GridBoard} this
         */
            'load',
        /**
         * @event recordcreate
         * Fires when a new record is created.
         * @param {Ext.data.Record} record The record that was created.
         */
            'recordcreate',
        /**
         * @event recordupdate
         * Fires when a record is updated.
         */
            'recordupdate',
        /**
         * @event preferencesaved
         * Fires after the preference has been saved
         * @param {Rally.data.wsapi.Model} record for preference
         */
            'preferencesaved',
        /**
         * @event modeltypeschange
         * Fires when the model types of the gridboard are changed.
         */
            'modeltypeschange',
        /**
         * @event updatefields
         * Fires when the fields are updated via the field picker.
         */
            'updatefields'
        ]);

        this.addStateEvents('updatefields','columnmove','columnresize','pagingtoolbarchange','sortchange');

        this.on('modeltypeschange', function (gridboard, types) {
            this.modelNames = types;
        }, this);
    },
    getFieldListStateId: function(){
        return this.context.getScopedStateId('shownfields');
    },
    /**
     * Delay the addition of the grid or board until plugins had a chance to modify some state
     * and the header has rendered in order to set the height of the tree grid.
     * Plugins can modify things like what fields are displayed
     * @private
     */
    afterRender: function () {
        this.callParent(arguments);
        this._addGrid();
    },
    destroy: function () {
        var grid = this.getGrid();

        if (grid && grid.store && _.isFunction(grid.store.clearData)) {
            //clean up records in the store to free up memory
            grid.store.clearData();
        }
        this.callParent(arguments);
    },
    getGrid: function () {
        return this.down('rallytreegrid');
    },
    /**
     * Get the header
     * @return {Rally.ui.LeftRight}
     */
    getHeader: function () {
        return this.down('#header');
    },
    /**
     * Get the names of the artifacts currently shown
     * @returns {String[]}
     */
    getModelNames: function () {
        return this.modelNames;
    },
    /**
     * Get the models of the artifacts currently shown
     * @returns {Rally.data.Model[]}
     */
    getModels: function () {
        return this.getGrid().getModels();
    },
    applyCustomFilter: function (filterObj) {
        var grid = this.getGrid();

        this.currentCustomFilter = filterObj;

        if (grid) {
            this._applyGridFilters(grid, filterObj);
        }
    },
    /**
     * Returns the currently applied filter.
     *
     * @returns {Ext.util.Filter|Ext.util.Filter[]|Object|Object[]}
     */
    getFilter: function () {
        return this.currentFilter;
    },

    setHeight: function () {
        this.callParent(arguments);
        var grid = this.getGrid();
        if (grid && grid.rendered && grid.getHeight() !== this.getAvailableGridBoardHeight()) {
            this.grid().setHeight(this.getAvailableGridBoardHeight());
        }
    },
    /**
     * @private
     */
    getAvailableGridBoardHeight: function () {
        return this.getHeight() - this.down('#header').getHeight() - 10;
    },
    /**
     * This function is called from the FieldPicker plugin to update the displayed fields
     * In the Gridboard, this calls the reconfigureWithColumns function on the TreeGrid
     * @param fields
     */
    updateFields: function(fields, reconfigureColumns, suspendLoad){

      //  var updated_fields = fields.concat(_.pluck(this.gridConfig.derivedColumns, 'dataIndex'));
        this.getGrid().reconfigureWithColumns(fields, reconfigureColumns, suspendLoad);

    },
    _getGridConfig: function () {

        var context = this.getContext() || Rally.environment.getContext(),
            customColumns = this.gridConfig.derivedColumns || [],
            columnCfgs = Ext.Array.merge(this.gridConfig.columnCfgs || [], customColumns),
            config = Ext.merge({
                xtype: 'rallytreegrid',
                context: context,
                enableRanking: context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled,
                defaultSortToRank: true,
                enableBlockedReasonPopover: true,
                height: this.getAvailableGridBoardHeight(),
                summaryColumns: this._getSummaryColumns()
            }, this.gridConfig);

            config.columnCfgs = columnCfgs;
        console.log('config.columnCfgs', columnCfgs);

        if (_.isEmpty(config.store)) {
            Ext.Error.raise('No grid store configured');
        }
        return config;
    },
    _getSummaryColumns: function(){
        return [];
    },

    _getConfiguredFilters: function (extraFilters, types) {
        var filters = _.compact(Ext.Array.merge(
            this.getGrid().store.filters,
            this.storeConfig && this.storeConfig.filters,
            this.gridConfig && this.gridConfig.storeConfig && this.gridConfig.storeConfig.filters,
            extraFilters));

        return filters;
    },
    _addGrid: function () {

        if (this.getGrid()){
            this.getGrid().destroy();
        }

        var grid = this.add(this._getGridConfig());
        this.mon(grid, 'afterproxyload', this._onGridLoad, this);

        if (this.currentCustomFilter) {
            this._applyGridFilters(grid, this.currentCustomFilter);
        }
       return grid;
    },
    _applyGridFilters: function (grid, filterObj) {
        if (!_.isEmpty(filterObj.types)) {
            grid.store.parentTypes = filterObj.types;
        }
        grid.store.clearFilter(true);
        grid.store.filter(this._getConfiguredFilters(filterObj.filters || [], filterObj.types || []));
    },
    _onGridLoad: function () {
        this.fireEvent('load', this);

        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    }

});
                Ext.define('PortfolioItemCostTracking.Utilities', {
    singleton: true,
    isPortfolioItem: function (type) {
        var portfolioItemRegExp = new RegExp('^portfolioitem/', "i");
        return portfolioItemRegExp.test(type);
    },

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        var blob = new Blob([csv],type_object);
        saveAs(blob,file_name);
    }
});


                Ext.define('PortfolioItemCostTracking.Exporter',{

    mixins: {
        observable: 'Ext.util.Observable'
    },

    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },
    saveAs: function(textToWrite, fileName)
    {
        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            window.BlobBuilder = window.BlobBuilder ||
                        window.WebKitBlobBuilder ||
                    window.MozBlobBuilder ||
                    window.MSBlobBuilder;
            if (window.BlobBuilder && e.name == 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    },
    fetchExportData: function(rootModel, rootFilters, fetch, columns){
        var deferred = Ext.create('Deft.Deferred');
        var rootFetch = Ext.Array.merge(fetch, PortfolioItemCostTracking.Settings.getPortfolioItemFetch());
        var me = this;

        PortfolioItemCostTracking.WsapiToolbox.fetchWsapiRecords(rootModel, rootFilters || [], rootFetch).then({
            scope: this,
            success: function(records){
                    console.log('records',records, fetch);
                  var loader = Ext.create('PortfolioItemCostTracking.RollupDataLoader',{
                    rootRecords: records,
                    additionalFetch: fetch,
                    listeners: {
                        rollupdataloaded: function(portfolioHash, stories){
                            var rollupData = Ext.create('PortfolioItemCostTracking.RollupCalculator', {});

                            portfolioHash[records[0].get('_type').toLowerCase()] = records;
                            rollupData.addRollupRecords(portfolioHash, stories);
                            rollupData.updateModels(records);

                            var exportData = me._getExportableRollupData(records,columns, rollupData);
                            columns = me._getAncestorTypeColumns(rootModel).concat(columns);

                            var csv = me._transformExportableRollupDataToDelimitedString(exportData, columns);
                            deferred.resolve(csv);
                        },
                        loaderror: function(msg){
                            deferred.reject(msg);
                        },
                        statusupdate: function(status){
                            this.fireEvent('statusupdate', status);
                        },
                        scope: this
                    }
                });
                loader.load(records);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    _transformExportableRollupDataToDelimitedString: function(rollupData, columns){
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n','g');

        var column_keys = _.map(columns, function(c){ return c.costField || c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(rollupData, function(obj){
            var data = [];
            Ext.Array.each(column_keys, function(key){
                var val = obj[key];
                if (val){
                    if (re.test(val)){ //enclose in double quotes if we have the delimiters
                        val = val.replace('"','\"\"');
                        val = Ext.String.format("\"{0}\"",val);
                    }
                }
               data.push(val);
            });
            csvArray.push(data.join(delimiter));
        });

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableRollupData: function(records, columns, rollupData){

        var exportData = [],
            me = this;


        _.each(records, function(r){
            var obj = rollupData.getRollupData(r);
            if (obj){
                var ancestors = {};
                var rec = obj.getExportRow(columns, ancestors);
                exportData.push(rec);
                me._addExportChildren(obj,exportData, columns, rollupData,ancestors);
            }
        }, this);
        return exportData;
    },
    _addExportChildren: function(obj, exportData, columns, rollupData,ancestors){
        var new_ancestors = Ext.clone(ancestors),
            me = this;
        new_ancestors[obj._type] = obj.FormattedID;

        var children = obj.children;
        if (children && children.length > 0){
            _.each(children, function(c){
                var row = c.getExportRow(columns, new_ancestors);
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, rollupData, new_ancestors);
            }, this);
        }
        return;
    },
    //_getExportDataRow: function(obj, columns, ancestors){
    //
    //    var rec = Ext.clone(ancestors),
    //        type = obj._type; //obj.getData('type');
    //
    //    rec[type] = obj.FormattedID;
    //    rec.type = PortfolioItemCostTracking.Settings.getTypePathDisplayName(obj._type);
    //    _.each(columns, function(c){
    //        var field = c.costField || c.dataIndex || null;
    //        if (field){
    //            var data = obj[field];
    //            console.log('data', field, data, obj);
    //            if (Ext.isObject(data)){
    //                rec[field] = data._refObjectName;
    //            } else if (Ext.isDate(data)){
    //                rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
    //            } else {
    //                rec[field] = data;
    //            }
    //        }
    //    });
    //    console.log('data', rec);
    //    return rec;
    //},
    _getAncestorTypeColumns: function(rootModel){
        var piTypes = PortfolioItemCostTracking.Settings.getPortfolioItemTypeObjects(),
            piIdx = -1;

        Ext.Array.each(piTypes, function(piObj, idx){
            if (piObj.typePath.toLowerCase() === rootModel.toLowerCase()){
                piIdx = idx;
            }
        });

        var columns = [{
            dataIndex: 'hierarchicalrequirement',
            text: 'User Story'
        }];

        if (piIdx >= 0){
            columns = columns.concat(Ext.Array.map(piTypes.slice(0,piIdx+1), function(piObj) { return { dataIndex: piObj.typePath.toLowerCase(), text: piObj.name };} ));
            columns.push({
                dataIndex: 'type',
                text: 'Artifact Type'
            });
            columns.reverse();
        }
        return columns;
    }
});


                Ext.define('PortfolioItemCostTracking.NumberFieldComboBox', {
    requires: [],
    extend: 'Rally.ui.combobox.FieldComboBox',
    alias: 'widget.numberfieldcombobox',
    _isNotHidden: function(field) {
        var validFields= ['PreliminaryEstimate','RefinedEstimate'];

        if (!field.hidden) {

            if (Ext.Array.contains(validFields, field.name)) {
                return true;
            }

            //Allow for custom number fields
            //if (field.custom && field.attributeDefinition) {
            //    return (field.attributeDefinition.AttributeType === "INTEGER" ||
            //    field.attributeDefinition.AttributeType === "DECIMAL");
            //
            //}
        }
        return false;
    }
});


            Rally.launchApp('PortfolioItemCostTracking', {
                name:"portfolio-item-cost-tracking",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
.lbl {
  text-transform: uppercase;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 10px;
}
.x-form-trigger-wrap {
  margin-top: 0px!important;
}
.x-column-header-text {
  margin-right: 0px!important;
}
.x-box-inner {
  overflow: visible;
}
p {
  color: #FAD200;
}

    </style>
</head>
<body>
</body>
</html>
